(window.webpackJsonp=window.webpackJsonp||[]).push([[15],{648:function(a,t,s){"use strict";s.r(t);var n=s(7),e=Object(n.a)({},(function(){var a=this,t=a.$createElement,s=a._self._c||t;return s("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[s("div",{staticClass:"custom-block tip"},[s("p",{staticClass:"title"}),s("p",[a._v("学习记录，待整理。")])]),a._v(" "),s("blockquote",[s("p",[s("strong",[a._v("20220124《大话数据结构》学习记录")])])]),a._v(" "),s("h3",{attrs:{id:"数据结构基本介绍"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#数据结构基本介绍"}},[a._v("#")]),a._v(" 数据结构基本介绍")]),a._v(" "),s("ul",[s("li",[a._v("程序设计=数据结构+算法")]),a._v(" "),s("li",[a._v("数据结构是相互之间存在一种或多种特定关系的数据元素的集合。")]),a._v(" "),s("li",[a._v("数据结构分为逻辑结构和物理结构。")]),a._v(" "),s("li",[a._v("逻辑结构：指数据对象中数据元素之间的相互关系。\n逻辑结构是针对具体问题的，是为了解决某个问题，在对问题的理解上，选择一个合适的数据结构表示数据元素之间的逻辑关系。\n"),s("ol",[s("li",[s("mark",[a._v("集合结构")]),a._v("：集合结构中的数据元素除了同属于一个集合外，他们之间没有其他关系。\n"),s("img",{staticStyle:{zoom:"50%"},attrs:{src:"C:\\Users\\hp\\AppData\\Roaming\\Typora\\typora-user-images\\image-20220125014151063.png",alt:"image-20220125014151063"}})]),a._v(" "),s("li",[s("mark",[a._v("线性结构")]),a._v("：线性结构中的数据元素之间是一对一的关系。\n"),s("img",{staticStyle:{zoom:"50%"},attrs:{src:"C:\\Users\\hp\\AppData\\Roaming\\Typora\\typora-user-images\\image-20220125014211279.png",alt:"image-20220125014211279"}})]),a._v(" "),s("li",[s("mark",[a._v("树形结构")]),a._v("：树形结构中的数据元素之间存在一种一对多的层次关系。\n"),s("img",{staticStyle:{zoom:"50%"},attrs:{src:"C:\\Users\\hp\\AppData\\Roaming\\Typora\\typora-user-images\\image-20220125014223018.png",alt:"image-20220125014223018"}})]),a._v(" "),s("li",[s("mark",[a._v("图形结构")]),a._v("：图形结构的数据元素是多对多的关系。\n"),s("img",{staticStyle:{zoom:"50%"},attrs:{src:"C:\\Users\\hp\\AppData\\Roaming\\Typora\\typora-user-images\\image-20220125014236069.png",alt:"image-20220125014236069"}})])])]),a._v(" "),s("li",[a._v("物理结构：指数据的逻辑结构在计算机中的存储形式\n"),s("mark",[a._v("数据的存储结构应该正确地反映数据元素之间的逻辑关系")]),a._v("。\n"),s("ol",[s("li",[s("mark",[a._v("顺序存储结构")]),a._v("：把数据元素存放在地址连续的存储单元里，其数据见的逻辑关系和物理关系是一致的。")]),a._v(" "),s("li",[s("mark",[a._v("链式存储结构")]),a._v("：把数据元素存放在任意的存储单元里，这组存储单元可以是连续的，也可以是不连续的。")])])]),a._v(" "),s("li",[a._v("逻辑结构是面向问题的，物理结构是面向计算机的，其基本的目标就是将数据及其逻辑关系存储到计算机的内存中。")])]),a._v(" "),s("h3",{attrs:{id:"线性表"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#线性表"}},[a._v("#")]),a._v(" 线性表")]),a._v(" "),s("ul",[s("li",[s("p",[a._v("线性表的定义")]),a._v(" "),s("ul",[s("li",[a._v("首先是一个序列，元素之间是由顺序的，第一个无前驱，最后一个无后继，其他元素有且只有一个前驱和后继。")]),a._v(" "),s("li",[a._v("然后，线性表强调是有限的。")]),a._v(" "),s("li",[a._v("数学语言定义如下：\n"),s("img",{staticStyle:{zoom:"80%"},attrs:{src:"C:\\Users\\hp\\AppData\\Roaming\\Typora\\typora-user-images\\image-20220125030147851.png",alt:"image-20220125030147851"}})])])]),a._v(" "),s("li",[s("p",[a._v("线性表的抽象数据类型")]),a._v(" "),s("ul",[s("li",[s("img",{attrs:{src:"C:%5CUsers%5Chp%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20220125030617661.png",alt:"image-20220125030617661"}}),a._v(" "),s("img",{attrs:{src:"C:%5CUsers%5Chp%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20220125030636354.png",alt:"image-20220125030636354"}})]),a._v(" "),s("li",[a._v("对于不同的应用，线性表的基本操作不同，上述操作是最基本的。对于复杂的个性化操作，其实就是把基本操作组合起来实现的。")])])]),a._v(" "),s("li",[s("p",[a._v("线性表的顺序存储结构")]),a._v(" "),s("ul",[s("li",[a._v("线性表的顺序存储结构，指的是用一段地址连续的存储单元依次存储线性表的数据元素。\n"),s("img",{staticStyle:{zoom:"80%"},attrs:{src:"C:\\Users\\hp\\AppData\\Roaming\\Typora\\typora-user-images\\image-20220125032204249.png",alt:"image-20220125032204249"}})])])]),a._v(" "),s("li",[s("p",[a._v("顺序存储结构的插入与删除")]),a._v(" "),s("ul",[s("li",[a._v("获得元素操作：存取时间性能O(1)。")]),a._v(" "),s("li",[a._v("插入操作：O(n)\n"),s("img",{staticStyle:{zoom:"80%"},attrs:{src:"C:\\Users\\hp\\AppData\\Roaming\\Typora\\typora-user-images\\image-20220125032803581.png",alt:"image-20220125032803581"}})]),a._v(" "),s("li",[a._v("删除操作：O(n)\n"),s("img",{staticStyle:{zoom:"80%"},attrs:{src:"C:\\Users\\hp\\AppData\\Roaming\\Typora\\typora-user-images\\image-20220125032913049.png",alt:"image-20220125032913049"}})]),a._v(" "),s("li",[a._v("由上述的时间复杂度分析，可知线性表比较适合元素个数不太变化，而更多是存取数据的应用。")]),a._v(" "),s("li",[s("mark",[a._v("线性表顺序存储结构的优缺点")]),a._v("：\n"),s("img",{staticStyle:{zoom:"80%"},attrs:{src:"C:\\Users\\hp\\AppData\\Roaming\\Typora\\typora-user-images\\image-20220125033430569.png",alt:"image-20220125033430569"}})])])]),a._v(" "),s("li",[s("p",[a._v("线性表的链式存储结构")]),a._v(" "),s("ul",[s("li",[a._v("线性表的顺序存储结构最大的缺点：插入和删除时需要移动大量元素，就需要耗费时间。")]),a._v(" "),s("li",[a._v("解决方法是所有元素都不要考虑相邻位置了，哪里有空位就到哪里。")]),a._v(" "),s("li",[a._v("线性表的链式存储结构的特点是用一组任意的存储单元存储线性表的数据元素。除了要存数据元素信息外，还要存储它的后继元素的存储地址。")]),a._v(" "),s("li",[a._v("存储数据元素信息的域称为数据域，把存储直接后继位置的域称为指针域。指针域中存储的信息称做指针或者链。这两部分信息组成数据元素的存储映像，称为结点。")]),a._v(" "),s("li",[a._v("单链表：链表的每个结点只包含一个指针域。")]),a._v(" "),s("li",[a._v("头指针：链表中第一个结点的存储位置。")]),a._v(" "),s("li",[a._v("头结点：为了方便对链表进行更多操作，会在单链表的第一个结点前附设一个结点。（头结点的数据域可以不存储任何东西，也可以存储如线性表的长度等附加信息，头结点的指针域存储指向第一个结点的指针）。")]),a._v(" "),s("li",[s("mark",[a._v("单链表是通过每个结点的指针域将线性表的数据元素按照其逻辑次序链接在一起")]),a._v("。")])])]),a._v(" "),s("li",[s("p",[a._v("单链表的读取")]),a._v(" "),s("ul",[s("li",[a._v("线性表的顺序存储结构中，计算任意一个元素的存储位置很容易。但在单链表中，没办法一开始就知道第i个元素在哪里，必须从头开始找。")]),a._v(" "),s("li",[a._v("最好的时间复杂度O(1)，最坏的时间复杂度O(n)。")]),a._v(" "),s("li",[a._v("获取链表第i个元素的算法思路：\n"),s("img",{staticStyle:{zoom:"80%"},attrs:{src:"C:\\Users\\hp\\AppData\\Roaming\\Typora\\typora-user-images\\image-20220125041850690.png",alt:"image-20220125041850690"}})]),a._v(" "),s("li",[a._v("从头开始找，直到第i个元素为止。主要核心思想："),s("strong",[a._v("工作指针后移")]),a._v("。")])])]),a._v(" "),s("li",[s("p",[a._v("单链表的插入与删除")]),a._v(" "),s("ul",[s("li",[a._v("单链表的插入：先找到元素，再改变指针即可\n"),s("img",{staticStyle:{zoom:"80%"},attrs:{src:"C:\\Users\\hp\\AppData\\Roaming\\Typora\\typora-user-images\\image-20220125044645202.png",alt:"image-20220125044645202"}})]),a._v(" "),s("li",[a._v("单链表的删除：先找到元素，再将他的前继结点的指针绕过，指向它的后继结点即可。\n"),s("img",{staticStyle:{zoom:"80%"},attrs:{src:"C:\\Users\\hp\\AppData\\Roaming\\Typora\\typora-user-images\\image-20220125044904973.png",alt:"image-20220125044904973"}})]),a._v(" "),s("li",[a._v("第一步遍历查找第i个元素，第二步插入和删除元素。整体上来说时间复杂度是O(n)，同顺序存储结构一样。但是，如果从第i个元素插入10个元素，优势就很明显。故其适合于对于插入或者删除数据越频繁的操作，单链表的效率优势也就是越是明显。")])])]),a._v(" "),s("li",[s("p",[a._v("单链表的整表创建")]),a._v(" "),s("ul",[s("li",[s("p",[a._v("顺序存储结构的创建：一个数组的初始化，即声明一个类型和大小的数组并赋值的过程")])]),a._v(" "),s("li",[s("p",[a._v("单链表的创建：一个动态生成链表的过程，即从空表的初始状态起，依次建立各元素结点，并逐个插入链表")])]),a._v(" "),s("li",[s("p",[a._v("算法思路：\n"),s("img",{staticStyle:{zoom:"80%"},attrs:{src:"C:\\Users\\hp\\AppData\\Roaming\\Typora\\typora-user-images\\image-20220125045448281.png",alt:"image-20220125045448281"}})])]),a._v(" "),s("li",[s("p",[a._v("头插法：")]),a._v(" "),s("blockquote",[s("p",[a._v("就是始终让新结点在第一的位置。")])]),a._v(" "),s("p",[a._v("先建立一个带头节点的单链表；")]),a._v(" "),s("p",[a._v("生成新结点；")]),a._v(" "),s("p",[a._v("随机赋值给新结点；")]),a._v(" "),s("p",[a._v("插入到表头。")]),a._v(" "),s("img",{staticStyle:{zoom:"80%"},attrs:{src:"C:\\Users\\hp\\AppData\\Roaming\\Typora\\typora-user-images\\image-20220125183007249.png",alt:"image-20220125183007249"}})]),a._v(" "),s("li",[s("p",[a._v("尾插法：")]),a._v(" "),s("blockquote",[s("p",[a._v("就是把每次新结点都插在终端结点的后面。")])]),a._v(" "),s("p",[a._v("先建立一个带头节点的单链表；")]),a._v(" "),s("p",[a._v("生成新结点；")]),a._v(" "),s("p",[a._v("随机赋值给新结点；")]),a._v(" "),s("p",[a._v("将表尾终端结点的指针指向新结点；")]),a._v(" "),s("p",[a._v("将当前的新节点定义为表尾终端结点。")]),a._v(" "),s("div",{staticClass:"language-c++ line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[a._v("void CreatListTail(LinkList *L, int n) {\n    LinkList p, r;\n    int i;\n    srand(time(0));\n    *L = (LinkList)malloc(sizeof(Node));\n    r=*L; // r为指向尾部的结点\n    for(i=0;i<n;i++){\n        P = (Node*)malloc(sizeof(Node)); // 生成新结点\n        p->data=rang()%100+1;\n        r->next=p; // 将表尾终端结点的指针指向新结点\n        r=p; // 将当前的新结点定义为表尾终端结点\n    }\n    r->next=NULL; // 表示当前链表结束\n}\n")])]),a._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[a._v("1")]),s("br"),s("span",{staticClass:"line-number"},[a._v("2")]),s("br"),s("span",{staticClass:"line-number"},[a._v("3")]),s("br"),s("span",{staticClass:"line-number"},[a._v("4")]),s("br"),s("span",{staticClass:"line-number"},[a._v("5")]),s("br"),s("span",{staticClass:"line-number"},[a._v("6")]),s("br"),s("span",{staticClass:"line-number"},[a._v("7")]),s("br"),s("span",{staticClass:"line-number"},[a._v("8")]),s("br"),s("span",{staticClass:"line-number"},[a._v("9")]),s("br"),s("span",{staticClass:"line-number"},[a._v("10")]),s("br"),s("span",{staticClass:"line-number"},[a._v("11")]),s("br"),s("span",{staticClass:"line-number"},[a._v("12")]),s("br"),s("span",{staticClass:"line-number"},[a._v("13")]),s("br"),s("span",{staticClass:"line-number"},[a._v("14")]),s("br")])])])])]),a._v(" "),s("li",[s("p",[a._v("单链表的整表删除")]),a._v(" "),s("ul",[s("li",[a._v("思路：\n"),s("img",{staticStyle:{zoom:"80%"},attrs:{src:"C:\\Users\\hp\\AppData\\Roaming\\Typora\\typora-user-images\\image-20220125185737409.png",alt:"image-20220125185737409"}})]),a._v(" "),s("li",[a._v("代码：\n"),s("img",{staticStyle:{zoom:"80%"},attrs:{src:"C:\\Users\\hp\\AppData\\Roaming\\Typora\\typora-user-images\\image-20220125185835207.png",alt:"image-20220125185835207"}})])])]),a._v(" "),s("li",[s("p",[a._v("单链表结构与顺序存储结构优缺点")]),a._v(" "),s("ul",[s("li",[a._v("若线性表需要频繁查找，很少进行插入和删除操作时，宜采用顺序存储结构。")]),a._v(" "),s("li",[a._v("若需要频繁插入和删除时，宜采用单链表结构。")]),a._v(" "),s("li",[a._v("当线性表中的元素个数变化较大或者根本不知道有多大时，最好用单链表结构，这样不用考虑存储空间的大小问题。")])])]),a._v(" "),s("li",[s("p",[a._v("静态链表")]),a._v(" "),s("ul",[s("li",[s("p",[a._v("用数组描述的链表叫做静态链表，也叫做游标实现法。")])]),a._v(" "),s("li",[s("p",[a._v("静态链表一般结构如下：\n数组第一个元素的cur存放备用链表(未被使用的数组元素)的第一个结点的下标；而数组的最后一个元素的cur则存放第一个有数值的元素的下标，相当于单链表中的头结点作用。")]),a._v(" "),s("img",{staticStyle:{zoom:"80%"},attrs:{src:"C:\\Users\\hp\\AppData\\Roaming\\Typora\\typora-user-images\\image-20220125192133241.png",alt:"image-20220125192133241"}})]),a._v(" "),s("li",[s("p",[a._v("静态链表的一个实例：\n"),s("img",{staticStyle:{zoom:"80%"},attrs:{src:"C:\\Users\\hp\\AppData\\Roaming\\Typora\\typora-user-images\\image-20220125193622591.png",alt:"image-20220125193622591"}})])]),a._v(" "),s("li",[s("p",[a._v("（C++中）在动态链表中，结点的申请和释放分别借用malloc()和free()两个函数实现。"),s("mark",[a._v("在java中如何操作")]),a._v("。")]),a._v(" "),s("p",[a._v("在静态链表中，操作的是数组，需要自己实现上面两个函数，才可以做插入和删除的操作。")])]),a._v(" "),s("li",[s("p",[a._v("静态链表插入操作：")]),a._v(" "),s("p",[a._v("以下代码实现了malloc()函数：")]),a._v(" "),s("img",{staticStyle:{zoom:"80%"},attrs:{src:"C:\\Users\\hp\\AppData\\Roaming\\Typora\\typora-user-images\\image-20220125200925043.png",alt:"image-20220125200925043"}}),a._v(" "),s("p",[a._v("插入时候改变结点的cur坐标即可。")])]),a._v(" "),s("li",[s("p",[a._v("静态链表删除操作：")]),a._v(" "),s("p",[a._v("删除在L中第i个数据元素e")]),a._v(" "),s("ul",[s("li",[a._v("首先判断i是否越界或者正确；")]),a._v(" "),s("li",[a._v("从1到i遍历链表，直至取到第i个数据元素的cur游标；")]),a._v(" "),s("li",[s("mark",[a._v("待补充")])])]),a._v(" "),s("p",[s("img",{attrs:{src:"C:%5CUsers%5Chp%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20220125201815796.png",alt:"image-20220125201815796"}})]),a._v(" "),s("p",[s("img",{attrs:{src:"C:%5CUsers%5Chp%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20220125202242277.png",alt:"image-20220125202242277"}})])]),a._v(" "),s("li",[s("p",[a._v("静态链表优缺点：")]),a._v(" "),s("p",[a._v("优点：插入和删除操作时，只需要修改游标，不需要移动元素，改进了顺序存储结构的缺点。")]),a._v(" "),s("p",[a._v("缺点："),s("font",{staticStyle:{color:"red"}},[a._v("没有解决连续存储分配带来的表长难以确定问题")]),a._v("。")],1),a._v(" "),s("p",[s("mark",[a._v("小结")]),a._v("：静态链表是为了给没有指针的高级语言设计的一种实现单链表能力的方法。")])])])]),a._v(" "),s("li",[s("p",[a._v("循环链表")]),a._v(" "),s("ul",[s("li",[a._v("单链表的一个缺点：单链表当中的某一结点无法找到它的前驱结点。而循环链表可以从某一个结点出发，访问到所有的结点。")]),a._v(" "),s("li",[a._v("循环链表：将单链表中终端结点的指针端由空指针改为指向头结点，就使整个单链表形成一个环，这种头尾相接的单链表称为单循环链表，简称循环链表。")]),a._v(" "),s("li",[s("mark",[a._v("待完善")])])])]),a._v(" "),s("li",[s("p",[a._v("双向链表")]),a._v(" "),s("ul",[s("li",[a._v("双向链表是在单链表的每个结点中，再设置一个指向其前驱结点的指针域。")]),a._v(" "),s("li",[s("mark",[a._v("待完善")])])])]),a._v(" "),s("li",[s("p",[a._v("总结")]),a._v(" "),s("ul",[s("li",[a._v("线性表是零个或多个具有相同类型的数据元素的有限序列。")]),a._v(" "),s("li",[a._v("整体结构：\n"),s("img",{staticStyle:{zoom:"80%"},attrs:{src:"C:\\Users\\hp\\AppData\\Roaming\\Typora\\typora-user-images\\image-20220125203611193.png",alt:"image-20220125203611193"}})])])])]),a._v(" "),s("blockquote",[s("p",[s("strong",[a._v("20220125数据结构理解")])])]),a._v(" "),s("ul",[s("li",[s("p",[a._v("线性表：属于逻辑结构中的线性结构，它包括顺序表和链表")])]),a._v(" "),s("li",[s("p",[a._v("顺序表：线性表中的一种，它是用数组来实现的一种线性表，所以它的存储结构(物理结构)是连续的")])]),a._v(" "),s("li",[s("p",[a._v("链表：线性表中的一种，它的存储结构是用任意一组存储单元来存储数据元素。存储结构可以是连续的，也可以是不连续的。有一种用数组来表示的链表，叫做静态链表，它的存储结构是连续的。")])]),a._v(" "),s("li",[s("p",[a._v("数组：①是一种线性表数据结构。②他用一组连续的存储空间，来存储一组具有相同类型的数据（因此支持随机访问，即根据下表随机访问的时间复杂度为O(1)）。")]),a._v(" "),s("center",[s("mark",[a._v("+++++++++++++++++++++++++截止线+++++++++++++++++++++++++")])])],1)]),a._v(" "),s("blockquote",[s("p",[s("strong",[a._v("20220206栈与队列读书笔记《大话数据结构》《数据结构与算法——Java》")])])]),a._v(" "),s("h3",{attrs:{id:"栈与队列"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#栈与队列"}},[a._v("#")]),a._v(" 栈与队列")]),a._v(" "),s("ul",[s("li",[s("p",[a._v("栈是限定仅在表尾进行插入和删除操作的线性表，队列是只允许在一端进行插入操作，而在另外一端进行删除操作的线性表")])]),a._v(" "),s("li",[s("p",[s("strong",[a._v("栈的定义")])]),a._v(" "),s("ul",[s("li",[a._v("栈是限定仅在表尾进行插入和删除操作的线性表。我们把允许插入和删除的一端称为栈顶，另一端称为栈底。栈是后进先出的线性表，LIFO。")]),a._v(" "),s("li",[a._v("栈是线性表，即栈元素具有线性关系，即前驱后继关系，只不过它是一种特殊的线性表而已。可以在线性表的表尾进行插入和删除操作，这里的表尾指的是栈顶。")])])]),a._v(" "),s("li",[s("p",[s("strong",[a._v("栈的抽象数据类型")]),a._v(" "),s("img",{staticStyle:{zoom:"80%"},attrs:{src:"C:\\Users\\hp\\AppData\\Roaming\\Typora\\typora-user-images\\image-20220206023855198.png",alt:"image-20220206023855198"}}),a._v(" "),s("img",{staticStyle:{zoom:"80%"},attrs:{src:"C:\\Users\\hp\\AppData\\Roaming\\Typora\\typora-user-images\\image-20220206023930997.png",alt:"image-20220206023930997"}})])]),a._v(" "),s("li",[s("p",[s("strong",[a._v("栈的顺序存储结构及其实现")])]),a._v(" "),s("ul",[s("li",[s("p",[a._v("简称顺序栈，下标为0的一端作为栈底，首元素存在栈底。使用栈顶指针top来指示栈顶元素在数组中的位置（栈存在一个元素，top=0；空栈，top=-1）。")])]),a._v(" "),s("li",[s("p",[a._v("此时入栈、出栈等操作可以在Ο(1)时间完成")])]),a._v(" "),s("li",[s("p",[a._v("堆栈在使用过程中所需的最大空间很难估计，因此，一般来说在构造堆栈时不应设定堆\n栈的最大容量。"),s("font",{staticStyle:{color:"red"}},[a._v("一种合理的做法和线性表的实现类似，先为堆栈分配一个基本容量，然后在实际的使用过程中，当堆栈的空间不够时再倍增存储空间")]),a._v("，这个过程所需的时间均摊到每个数据元素时间为Θ(1)，不会影响操作实现的时间复杂度。")],1)]),a._v(" "),s("li",[s("p",[a._v("入栈（栈的插入）")])])]),a._v(" "),s("div",{staticClass:"language-java line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-java"}},[s("code",[s("span",{pre:!0,attrs:{class:"token comment"}},[a._v("// 数据元素e入栈")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Public")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("void")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[a._v("push")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Object")]),a._v(" e"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("\n    "),s("span",{pre:!0,attrs:{class:"token comment"}},[a._v("// 先判断堆栈的大小是否达到栈元素数组的大小，达到了就先扩容")]),a._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("if")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token function"}},[a._v("getSize")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v(">=")]),a._v("elements"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),a._v("length"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v("\n        "),s("span",{pre:!0,attrs:{class:"token function"}},[a._v("expandSpace")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n    elements"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("[")]),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("++")]),a._v("top"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("]")]),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v("e"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("public")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("void")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[a._v("expandSpace")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("\n    "),s("span",{pre:!0,attrs:{class:"token comment"}},[a._v("// 扩容成2倍")]),a._v("\n    "),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Object")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("[")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("]")]),a._v(" a "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("new")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Object")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("[")]),a._v("elements"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),a._v("length"),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("*")]),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("2")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("]")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n    "),s("span",{pre:!0,attrs:{class:"token comment"}},[a._v("// 复制到新数组")]),a._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("for")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("int")]),a._v(" i"),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("0")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v(" i"),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("<")]),a._v("elements"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),a._v("length"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v(" i"),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("++")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("\n        a"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("[")]),a._v("i"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("]")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" elements"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("[")]),a._v("i"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("]")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n    "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v("\n    "),s("span",{pre:!0,attrs:{class:"token comment"}},[a._v("// 换")]),a._v("\n    elements "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" a"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v("\n")])]),a._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[a._v("1")]),s("br"),s("span",{staticClass:"line-number"},[a._v("2")]),s("br"),s("span",{staticClass:"line-number"},[a._v("3")]),s("br"),s("span",{staticClass:"line-number"},[a._v("4")]),s("br"),s("span",{staticClass:"line-number"},[a._v("5")]),s("br"),s("span",{staticClass:"line-number"},[a._v("6")]),s("br"),s("span",{staticClass:"line-number"},[a._v("7")]),s("br"),s("span",{staticClass:"line-number"},[a._v("8")]),s("br"),s("span",{staticClass:"line-number"},[a._v("9")]),s("br"),s("span",{staticClass:"line-number"},[a._v("10")]),s("br"),s("span",{staticClass:"line-number"},[a._v("11")]),s("br"),s("span",{staticClass:"line-number"},[a._v("12")]),s("br"),s("span",{staticClass:"line-number"},[a._v("13")]),s("br"),s("span",{staticClass:"line-number"},[a._v("14")]),s("br"),s("span",{staticClass:"line-number"},[a._v("15")]),s("br"),s("span",{staticClass:"line-number"},[a._v("16")]),s("br"),s("span",{staticClass:"line-number"},[a._v("17")]),s("br")])]),s("ul",[s("li",[s("p",[a._v("出栈")]),a._v(" "),s("div",{staticClass:"language-java line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-java"}},[s("code",[s("span",{pre:!0,attrs:{class:"token comment"}},[a._v("// 栈顶元素出栈")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("public")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Object")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[a._v("pop")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("throws")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("StackEmptyException")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("if")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token function"}},[a._v("getSize")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("<")]),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("1")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v("\n        "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("throw")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("new")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("StackEmptyException")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token string"}},[a._v('"错误，堆栈为空。"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n    "),s("span",{pre:!0,attrs:{class:"token comment"}},[a._v("// 取出栈顶元素")]),a._v("\n    "),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Object")]),a._v(" obj "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" elements"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("[")]),a._v("top"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("]")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n    "),s("span",{pre:!0,attrs:{class:"token comment"}},[a._v("// 置为null")]),a._v("\n    elements"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("[")]),a._v("top"),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("--")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("]")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("null")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n    "),s("span",{pre:!0,attrs:{class:"token comment"}},[a._v("// 返回栈顶元素")]),a._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("return")]),a._v(" obj"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v("\n")])]),a._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[a._v("1")]),s("br"),s("span",{staticClass:"line-number"},[a._v("2")]),s("br"),s("span",{staticClass:"line-number"},[a._v("3")]),s("br"),s("span",{staticClass:"line-number"},[a._v("4")]),s("br"),s("span",{staticClass:"line-number"},[a._v("5")]),s("br"),s("span",{staticClass:"line-number"},[a._v("6")]),s("br"),s("span",{staticClass:"line-number"},[a._v("7")]),s("br"),s("span",{staticClass:"line-number"},[a._v("8")]),s("br"),s("span",{staticClass:"line-number"},[a._v("9")]),s("br"),s("span",{staticClass:"line-number"},[a._v("10")]),s("br"),s("span",{staticClass:"line-number"},[a._v("11")]),s("br")])])])])]),a._v(" "),s("li",[s("p",[s("strong",[a._v("栈的链式存储结构及其实现")])]),a._v(" "),s("ul",[s("li",[s("p",[a._v("简称链栈。")])]),a._v(" "),s("li",[s("p",[a._v("当采用单链表存储线性表后，根据单链表的操作特性选择单链表的头部作为栈顶（在栈底进行入栈和出栈操作）（这里可以将单链表的头指针和栈顶指针合二为一），此时，入栈、出栈等操作可以在Ο(1)内完成\n"),s("img",{staticStyle:{zoom:"67%"},attrs:{src:"C:\\Users\\hp\\AppData\\Roaming\\Typora\\typora-user-images\\image-20220206034212874.png",alt:"image-20220206034212874"}})])]),a._v(" "),s("li",[s("p",[a._v("空栈，链表原定义是头指针指向空。")])]),a._v(" "),s("li",[s("p",[a._v("使用待头结点的单链表时，结点的插入和删除都在头结点之后进行；使用不带头结点的单链表时，结点的插入和删除都在链表的首结点上进行。")])]),a._v(" "),s("li",[s("p",[a._v("例子（使用不带头结点的单链表实现堆栈）\n"),s("img",{staticStyle:{zoom:"80%"},attrs:{src:"C:\\Users\\hp\\AppData\\Roaming\\Typora\\typora-user-images\\image-20220206043025954.png",alt:"image-20220206043025954"}}),a._v("\ntop始终指向当前栈顶元素所在结点。"),s("font",{staticStyle:{color:"red"}},[a._v("入栈操作是在 top 所指结点之前插入新的结点")]),a._v("。对于出栈操作，都是将top后移。")],1)]),a._v(" "),s("li",[s("p",[a._v("入栈")]),a._v(" "),s("div",{staticClass:"language-java line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-java"}},[s("code",[s("span",{pre:!0,attrs:{class:"token comment"}},[a._v("// Stack接口")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("public")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("interface")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Stack")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("\n    "),s("span",{pre:!0,attrs:{class:"token comment"}},[a._v("//返回堆栈的大小")]),a._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("public")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("int")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[a._v("getSize")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n    "),s("span",{pre:!0,attrs:{class:"token comment"}},[a._v("//判断堆栈是否为空")]),a._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("public")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("boolean")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[a._v("isEmpty")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n    "),s("span",{pre:!0,attrs:{class:"token comment"}},[a._v("//数据元素 e 入栈")]),a._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("public")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("void")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[a._v("push")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Object")]),a._v(" e"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n    "),s("span",{pre:!0,attrs:{class:"token comment"}},[a._v("//栈顶元素出栈")]),a._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("public")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Object")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[a._v("pop")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("throws")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("StackEmptyException")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n    "),s("span",{pre:!0,attrs:{class:"token comment"}},[a._v("//取栈顶元素")]),a._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("public")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Object")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[a._v("peek")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("throws")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("StackEmptyException")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v("\n")])]),a._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[a._v("1")]),s("br"),s("span",{staticClass:"line-number"},[a._v("2")]),s("br"),s("span",{staticClass:"line-number"},[a._v("3")]),s("br"),s("span",{staticClass:"line-number"},[a._v("4")]),s("br"),s("span",{staticClass:"line-number"},[a._v("5")]),s("br"),s("span",{staticClass:"line-number"},[a._v("6")]),s("br"),s("span",{staticClass:"line-number"},[a._v("7")]),s("br"),s("span",{staticClass:"line-number"},[a._v("8")]),s("br"),s("span",{staticClass:"line-number"},[a._v("9")]),s("br"),s("span",{staticClass:"line-number"},[a._v("10")]),s("br"),s("span",{staticClass:"line-number"},[a._v("11")]),s("br"),s("span",{staticClass:"line-number"},[a._v("12")]),s("br"),s("span",{staticClass:"line-number"},[a._v("13")]),s("br")])])]),a._v(" "),s("li",[s("p",[a._v("出栈")]),a._v(" "),s("div",{staticClass:"language-java line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-java"}},[s("code",[a._v("    "),s("span",{pre:!0,attrs:{class:"token comment"}},[a._v("//栈顶元素出栈")]),a._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("public")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Object")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[a._v("pop")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("throws")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("StackEmptyException")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("\n        "),s("span",{pre:!0,attrs:{class:"token comment"}},[a._v("// 判断栈是否为空")]),a._v("\n        "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("if")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),a._v("size"),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("<")]),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("1")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v("\n            "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("throw")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("new")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("StackEmptyException")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token string"}},[a._v('"错误，堆栈为空。"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n        "),s("span",{pre:!0,attrs:{class:"token comment"}},[a._v("// 得到栈顶元素结点的数据")]),a._v("\n        "),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Object")]),a._v(" obj "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" top"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[a._v("getData")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n        "),s("span",{pre:!0,attrs:{class:"token comment"}},[a._v("// 将栈顶元素结点指向的下一个结点替换上来")]),a._v("\n        top "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" top"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[a._v("getNext")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n        size"),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("--")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n        "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("return")]),a._v(" obj"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n    "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v("\n")])]),a._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[a._v("1")]),s("br"),s("span",{staticClass:"line-number"},[a._v("2")]),s("br"),s("span",{staticClass:"line-number"},[a._v("3")]),s("br"),s("span",{staticClass:"line-number"},[a._v("4")]),s("br"),s("span",{staticClass:"line-number"},[a._v("5")]),s("br"),s("span",{staticClass:"line-number"},[a._v("6")]),s("br"),s("span",{staticClass:"line-number"},[a._v("7")]),s("br"),s("span",{staticClass:"line-number"},[a._v("8")]),s("br"),s("span",{staticClass:"line-number"},[a._v("9")]),s("br"),s("span",{staticClass:"line-number"},[a._v("10")]),s("br"),s("span",{staticClass:"line-number"},[a._v("11")]),s("br"),s("span",{staticClass:"line-number"},[a._v("12")]),s("br")])])])])]),a._v(" "),s("li",[s("p",[s("strong",[a._v("两种实现对比")])]),a._v(" "),s("ul",[s("li",[a._v("时间复杂度均为O(1)")]),a._v(" "),s("li",[a._v("顺序栈需要事先确定一个固定的长度，可能存在内存空间浪费的问题，("),s("mark",[a._v("这个没有明白，不是只能在栈顶操作吗???")]),a._v(")优势在于存取时定位很方便")]),a._v(" "),s("li",[a._v("链栈要求每个元素都有指针域，同时也增加了一些内存开销，但是栈的长度无限制")])])]),a._v(" "),s("li",[s("p",[s("strong",[s("mark",[a._v("栈的作用")])])]),a._v(" "),s("ul",[s("li",[a._v("栈的引入简化了程序设计的问题，划分了不同关注层次，使得思考范围缩小，更加聚焦于我们要解决的问题核心。例如，对于数组，要分散精力考虑数组的下标增减等细节问题，掩盖了问题的本质")]),a._v(" "),s("li",[a._v("Java有对栈结构的封装，可以不用关注它的实现细节，就直接可以使用它的方法，很方便。")])])]),a._v(" "),s("li",[s("p",[s("strong",[a._v("栈的应用1——递归")])]),a._v(" "),s("ul",[s("li",[s("p",[a._v("例如：斐波那契数列")])]),a._v(" "),s("li",[s("p",[s("mark",[a._v("有两种实现方式")]),a._v("：")]),a._v(" "),s("ul",[s("li",[a._v("迭代实现：使用循环结构。迭代不需要反复调用函数和占用额外内存。")]),a._v(" "),s("li",[a._v("递归实现：使用选择结构。程序更加清晰简洁。使用大量的递归调用会建立函数的副本，消耗大量的时间和内存。")]),a._v(" "),s("li",[a._v("视不同情况选择不同的实现方式。")])])]),a._v(" "),s("li",[s("p",[s("mark",[a._v("递归和栈的关系")])]),a._v(" "),s("ul",[s("li",[s("p",[a._v("得从计算机系统说起")])]),a._v(" "),s("li",[s("p",[a._v("这个递归实现的机制符合栈这种结构，对于现在的高级语言，这样的递归问题，是不需要用户来管理这个栈的，一切都由系统来代劳了")]),a._v(" "),s("img",{staticStyle:{zoom:"80%"},attrs:{src:"C:\\Users\\hp\\AppData\\Roaming\\Typora\\typora-user-images\\image-20220206082955404.png",alt:"image-20220206082955404"}})])])])])]),a._v(" "),s("li",[s("p",[s("strong",[a._v("栈的应用2——四则运算表达式求值")])]),a._v(" "),s("ul",[s("li",[s("mark",[a._v("待实现")])]),a._v(" "),s("li",[a._v("栈的现实应用。四则 运算中，计算机需要实现先计算乘除，以及先计算括号，这样如何实现呢？ ——>> 后缀表达法")]),a._v(" "),s("li",[a._v("后缀表达法：它是表达式的一种新的显示方式，非常巧妙的解决了四则运算的难题。")]),a._v(" "),s("li",[a._v("后缀表达式的规则：从左到右地遍历表达式的每个数字和符号，遇到数字就进栈，遇到符号就将处于栈顶的两个数字出栈，进行运算，运算结果进栈，一直到最终获得结果。")]),a._v(" "),s("li",[a._v("那么如何得到后缀表达式呢？ ——>>  平时所用的式子叫做中缀表达式，转换得到后缀表达式。遵循以下规则：从左到右遍历中缀表达式的每个数字和符号。若是数字就输出，即成为后缀表达式的一部分。若是符号，则判断其与栈顶符号的优先级，是右括号或者优先级低于栈顶符号（惩处优先加减）则栈顶元素依次出栈并且输出，并且将当前符号进栈，一直到最终输出后缀表达式为止。")]),a._v(" "),s("li",[s("img",{attrs:{src:"C:%5CUsers%5Chp%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20220206100143638.png",alt:"image-20220206100143638"}})]),a._v(" "),s("li",[a._v("整个过程都充分利用了栈的后进先出特性来处理。")])])]),a._v(" "),s("li",[s("p",[s("strong",[a._v("栈的应用3——_")])]),a._v(" "),s("ul",[s("li",[s("mark",[a._v("待实现")])])])]),a._v(" "),s("li",[s("p",[s("strong",[a._v("队列的定义")])]),a._v(" "),s("ul",[s("li",[a._v("队列是只允许在一端进行插入操作，而在另外一端进行删除操作的线性表。")]),a._v(" "),s("li",[a._v("先进先出的线性表。允许插入的一段称为队尾，允许删除的一端称为队头。\n"),s("img",{staticStyle:{zoom:"80%"},attrs:{src:"C:\\Users\\hp\\AppData\\Roaming\\Typora\\typora-user-images\\image-20220206175340986.png",alt:"image-20220206175340986"}})])])]),a._v(" "),s("li",[s("p",[s("strong",[a._v("队列的抽象数据类型")])]),a._v(" "),s("ul",[s("li",[a._v("同样是线性表，队列也有类似线性表的各种操作，不同的就是插入数据只能在队尾进行，删除数据只能在队头进行")]),a._v(" "),s("li",[s("img",{attrs:{src:"C:%5CUsers%5Chp%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20220206175616926.png",alt:"image-20220206175616926"}})])])]),a._v(" "),s("li",[s("p",[s("strong",[a._v("队列的顺序存储实现")])]),a._v(" "),s("ul",[s("li",[a._v("入队操作的时间复杂度为O(1)")]),a._v(" "),s("li",[a._v("出队，队列中的所有元素都得向前移动，以保证队列的队头，也就是下标为0的为止不为空，此时时间复杂度为O(n)")]),a._v(" "),s("li",[a._v("想一下，为什么出队列一定都得全部移动呢（若不去限制队列的元素都必须存储在数组的前n个单元这个条件），出队的性能就会大大增加（也就是说，队头不需要一定在下标为0的位置）\n"),s("img",{staticStyle:{zoom:"80%"},attrs:{src:"C:\\Users\\hp\\AppData\\Roaming\\Typora\\typora-user-images\\image-20220206182849525.png",alt:"image-20220206182849525"}})]),a._v(" "),s("li",[s("mark",[a._v("循环队列")]),a._v("：把队列的这种头尾相接的顺序存储结构")]),a._v(" "),s("li",[a._v("出现问题：空队列时，front=rear；队列满时，front=rear。此时如何判断呢？")]),a._v(" "),s("li",[a._v("解决问题：\n"),s("ul",[s("li",[a._v("第一种：设置标志变量")]),a._v(" "),s("li",[s("mark",[a._v("第二种")]),a._v("：队列空时，front=rear；队列满时，修改其条件，保留一个元素空间。队列满的条件就是(rear+1)%QueueSize==front（以下例子实验即可）（也可以通过得到实际大小=QueueSize-1得到）。通过归纳（rear和front的关系）得到计算通用的计算队列长度公式为：\n(rear-front+QueueSize)%QueueSize。\n"),s("img",{attrs:{src:"C:%5CUsers%5Chp%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20220206183449821.png",alt:"image-20220206183449821"}})])])]),a._v(" "),s("li",[a._v("若只是顺序存储而不是循环队列，那么算法的时间性能是不高的，但是循环队列又面临着数组可能会溢出的问题。——>> 不需要担心队列长度的链式存储结构。")])])]),a._v(" "),s("li",[s("p",[s("strong",[a._v("队列的链式存储实现")])]),a._v(" "),s("ul",[s("li",[a._v("它是线性表的单链表，只不过只能尾进头出去，简称为链队列")]),a._v(" "),s("li",[a._v("队头指针指向链队列的头结点，而队尾指针指向终端结点\n"),s("img",{staticStyle:{zoom:"80%"},attrs:{src:"C:\\Users\\hp\\AppData\\Roaming\\Typora\\typora-user-images\\image-20220207014401616.png",alt:"image-20220207014401616"}})]),a._v(" "),s("li",[a._v("空队列：front和rear都指向头结点")])])]),a._v(" "),s("li",[s("p",[s("strong",[a._v("循环队列和链队列的比较")])]),a._v(" "),s("img",{staticStyle:{zoom:"80%"},attrs:{src:"C:\\Users\\hp\\AppData\\Roaming\\Typora\\typora-user-images\\image-20220207014928534.png",alt:"image-20220207014928534"}})])]),a._v(" "),s("center",[s("mark",[a._v("+++++++++++++++++++++++++截止线+++++++++++++++++++++++++")])]),a._v(" "),s("blockquote",[s("p",[s("strong",[a._v("20220210《数据结构与算法--Java》《大话数据结构》树学习记录")])])]),a._v(" "),s("center",[s("h3",[a._v("树")])]),a._v(" "),s("ul",[s("li",[s("p",[s("strong",[a._v("树的定义")])]),a._v(" "),s("ul",[s("li",[a._v("一对多的数据结构——树")]),a._v(" "),s("li",[a._v("通过“树”的各种特性，可以解决我们编程中遇到的相关问题")]),a._v(" "),s("li",[a._v("数据结构中的“树”只有一个根结点")]),a._v(" "),s("li",[a._v("树的结点：根结点，内部节点，叶结点或终端结点")]),a._v(" "),s("li",[a._v("树中结点的最大层次称为树的深度或高度")]),a._v(" "),s("li",[a._v("如果将树中结点的各个子树看成从左至右是有次序的，不能互换的，则称该树为有序树，否则称为无序树")]),a._v(" "),s("li",[s("font",{staticStyle:{color:"red"}},[a._v("注意")]),a._v("：线性表和树的结点，有很大的不同\n"),s("img",{staticStyle:{zoom:"80%"},attrs:{src:"C:\\Users\\hp\\AppData\\Roaming\\Typora\\typora-user-images\\image-20220210075722510.png",alt:"image-20220210075722510"}})],1)])]),a._v(" "),s("li",[s("p",[s("strong",[a._v("树的抽象数据类型")])]),a._v(" "),s("img",{staticStyle:{zoom:"80%"},attrs:{src:"C:\\Users\\hp\\AppData\\Roaming\\Typora\\typora-user-images\\image-20220210080348389.png",alt:"image-20220210080348389"}})]),a._v(" "),s("li",[s("p",[s("strong",[a._v("树的存储结构")])]),a._v(" "),s("ul",[s("li",[a._v("存储结构分为：顺序存储结构与链式存储结构。")]),a._v(" "),s("li",[a._v("树中某个结点的孩子可以有多个，这就意味着，无论何种顺序将树中所有结点存储到数组中，结点的存储位置都无法直接反映逻辑关系（数据元素挨个存储分不清谁是谁的双亲，谁是谁的孩子）。"),s("font",{staticStyle:{color:"red"}},[a._v("简单的顺序存储结构是不能满足树的实现要求的")]),a._v("。")],1),a._v(" "),s("li",[s("font",{staticStyle:{color:"red"}},[a._v("充分利用顺序存储和链式存储结构的特点，完全可以实现对树的存储结构的表示")]),a._v("。")],1),a._v(" "),s("li",[s("font",{staticStyle:{color:"red"}},[a._v("三种树的存储结构的表示法")]),a._v("：双亲表示法，孩子表示法，孩子兄弟表示法。")],1),a._v(" "),s("li",[s("u",[a._v("双亲表示法")]),a._v("：用一个一维数组存储每个结点，"),s("font",{staticStyle:{color:"red"}},[a._v("数组的下标")]),a._v("就是结点的位置指针，每个结点中有一个"),s("font",{staticStyle:{color:"red"}},[a._v("指向各自的父亲结点的数组下标的域")]),a._v("。由于树中每个结点的父亲是唯一的，所有上述的父亲数组表示法可以唯一地表示任何一棵树。\n"),s("img",{staticStyle:{zoom:"80%"},attrs:{src:"C:\\Users\\hp\\AppData\\Roaming\\Typora\\typora-user-images\\image-20220210082947541.png",alt:"image-20220210082947541"}})],1),a._v(" "),s("li",[s("u",[a._v("孩子链表表示法")]),a._v("：这种表示法用一个线性表来存储树的所有结点信息，称为结点表。"),s("font",{staticStyle:{color:"red"}},[a._v("对每个结点建立一个孩子表")]),a._v("。孩子表中只"),s("font",{staticStyle:{color:"red"}},[a._v("存储孩子结点的地址信息")]),a._v("，可以是指针，数组下标甚至内存地址。由于"),s("font",{staticStyle:{color:"red"}},[a._v("每个结点的孩子数目不定，因此孩子表常用单链表来实现")]),a._v("，因此这种表示法称为孩子链表表示法。\n"),s("img",{staticStyle:{zoom:"80%"},attrs:{src:"C:\\Users\\hp\\AppData\\Roaming\\Typora\\typora-user-images\\image-20220210083035810.png",alt:"image-20220210083035810"}})],1),a._v(" "),s("li",[s("u",[a._v("孩子兄弟表示法")]),a._v("：树的孩子兄弟表示法又称为二叉树表示法。"),s("font",{staticStyle:{color:"red"}},[a._v("每个结点除了data域外，还含有两个域，分别指向该结点的第一个孩子和右邻兄弟")]),a._v("。"),s("big",[a._v("这种是使用二叉链表来进行存储，这种结构便于实现树的各种操作")]),a._v("。\n"),s("img",{staticStyle:{zoom:"80%"},attrs:{src:"C:\\Users\\hp\\AppData\\Roaming\\Typora\\typora-user-images\\image-20220210083108410.png",alt:"image-20220210083108410"}})],1)])]),a._v(" "),s("li",[s("p",[s("strong",[a._v("二叉树的定义")])]),a._v(" "),s("ul",[s("li",[a._v("二叉树是n个结点的有限集合，该集合或者为空集（空二叉树），或者由一个根结点和两颗互不相交的，分别称为根节点的左子树和右子树的二叉树组成。")]),a._v(" "),s("li",[s("u",[a._v("斜树")]),a._v("：所有的结点都只有左子树的二叉树叫做左斜树，和右斜树统称为斜树。"),s("font",{staticStyle:{color:"red"}},[a._v("线性表结构就可以理解为树的一种极其特殊的表现形式")]),a._v("。")],1),a._v(" "),s("li",[s("u",[a._v("满二叉树")]),a._v("：所有分支结点都存在左子树和右子树")]),a._v(" "),s("li",[s("u",[a._v("完全二叉树")]),a._v("：\n"),s("img",{staticStyle:{zoom:"50%"},attrs:{src:"C:\\Users\\hp\\AppData\\Roaming\\Typora\\typora-user-images\\image-20220210092054598.png",alt:"image-20220210092054598"}})])])]),a._v(" "),s("li",[s("p",[s("strong",[a._v("二叉树的性质")])]),a._v(" "),s("ul",[s("li",[s("img",{attrs:{src:"C:%5CUsers%5Chp%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20220210092157406.png",alt:"image-20220210092157406"}})]),a._v(" "),s("li",[s("img",{attrs:{src:"C:%5CUsers%5Chp%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20220210092311255.png",alt:"image-20220210092311255"}})]),a._v(" "),s("li",[a._v("性质3：对于任何一颗二叉树T，如果其终端结点数为n0，度为2的结点数为n2，则n0=n2+1。")])])]),a._v(" "),s("li",[s("p",[s("strong",[a._v("二叉树的存储结构")])]),a._v(" "),s("ul",[s("li",[a._v("二叉树的存储结构有两种：顺序存储结构和链式存储结构。")]),a._v(" "),s("li",[s("u",[a._v("顺序存储结构")]),a._v("：\n"),s("ul",[s("li",[a._v("对于满二叉树和完全二叉树来说，可以将其数据元素逐层存放到一组连续的存储单元中，用一维数组来实现顺序存储结构时，可以将二叉树中编号为i的结点存放到数组中的第i个分量中。可以得到结点 i 的父结点、左右孩子结点分别存放在 、2i 以及 2i+1 分量中。\n"),s("img",{staticStyle:{zoom:"80%"},attrs:{src:"C:\\Users\\hp\\AppData\\Roaming\\Typora\\typora-user-images\\image-20220210193618960.png",alt:"image-20220210193618960"}})]),a._v(" "),s("li",[a._v("这种存储方式对于满二叉树和完全二叉树非常合适且高效方便。因为既不浪费空间，也可以根据公式很快的确定结点之间的关系。")]),a._v(" "),s("li",[a._v("对于一般的二叉树而言，必须用“虚结点”将一棵二叉树补成一棵完全二叉树来存储，\n否则无法确定结点之间的前驱后续关系，但是这样一来就会造成空间的浪费。\n"),s("img",{staticStyle:{zoom:"80%"},attrs:{src:"C:\\Users\\hp\\AppData\\Roaming\\Typora\\typora-user-images\\image-20220210193932657.png",alt:"image-20220210193932657"}})])])]),a._v(" "),s("li",[s("u",[a._v("链式存储结构")]),a._v("：\n"),s("ul",[s("li",[a._v("设计不同的结点结构可构成不同的链式存储结构。在二叉树中每个结点都有两个孩子，则可以设计每个结点至少包括 3 个域：数据域、左孩子域和右孩子域。数据域存放数据元素，左孩子域存放指向左孩子结点的指针，右孩子域存放指向右孩子结点的指针。\n"),s("img",{staticStyle:{zoom:"80%"},attrs:{src:"C:\\Users\\hp\\AppData\\Roaming\\Typora\\typora-user-images\\image-20220210194114038.png",alt:"image-20220210194114038"}})]),a._v(" "),s("li",[a._v("不同的存储结构实现二叉树操作的方法也不同。例如要找某个结点的父结点，在三叉链表中很容易实现；在二叉链表中则需从根结点出发一一查找。在实际应用中，要根据二叉树的主要操作来选择存储结构。")]),a._v(" "),s("li",[a._v("为了方便的找到父结点，我们以三叉链表作为二叉树的存储结构，")])])])])]),a._v(" "),s("li",[s("p",[s("strong",[a._v("遍历二叉树")])]),a._v(" "),s("ul",[s("li",[a._v("二叉树的遍历指的是从根结点出发，按照某种次序依次访问二叉树中所有结点，使每个结点被访问依次且仅被访问以次。")]),a._v(" "),s("li",[a._v("计算机只能处理线性序列，以下几种遍历方法，都是把树中的结点变成某种意义的线性序列，")]),a._v(" "),s("li",[a._v("前序遍历，中序遍历，后序遍历，层序遍历")]),a._v(" "),s("li",[a._v("前序遍历：若二叉树为空，则空操作返回，否则先访问根结点，然后前序遍历左子树，再前序遍历右子树。  ==>   ABDGHCEIF。\n"),s("img",{staticStyle:{zoom:"80%"},attrs:{src:"C:\\Users\\hp\\AppData\\Roaming\\Typora\\typora-user-images\\image-20220211093711414.png",alt:"image-20220211093711414"}})]),a._v(" "),s("li",[a._v("中序遍历：若树为空，则空操作返回，否则从根结点开始，中序遍历根结点的左子树，然后是访问根结点，最后中序遍历右子树。GDHBAEICF。\n"),s("img",{staticStyle:{zoom:"80%"},attrs:{src:"C:\\Users\\hp\\AppData\\Roaming\\Typora\\typora-user-images\\image-20220211093730318.png",alt:"image-20220211093730318"}})]),a._v(" "),s("li",[a._v("后序遍历：从左到右先叶子后结点的方式遍历访问左右子树，最后是访问根结点。GHDBIEFCA。\n"),s("img",{staticStyle:{zoom:"80%"},attrs:{src:"C:\\Users\\hp\\AppData\\Roaming\\Typora\\typora-user-images\\image-20220211093808683.png",alt:"image-20220211093808683"}})]),a._v(" "),s("li",[a._v("层序遍历：从树的第一层，也就是根结点开始访问，从上而下逐层遍历，在同一层中，按从左到右的顺序对结点逐个访问。\n"),s("img",{staticStyle:{zoom:"80%"},attrs:{src:"C:\\Users\\hp\\AppData\\Roaming\\Typora\\typora-user-images\\image-20220211093826865.png",alt:"image-20220211093826865"}})])])]),a._v(" "),s("li",[s("p",[s("strong",[a._v("由遍历序列还原树结构")])]),a._v(" "),s("blockquote",[s("p",[a._v("这里尚且不够熟练。")])]),a._v(" "),s("ul",[s("li",[a._v("通过二叉树的一种遍历序列是无法还原二叉树的。")]),a._v(" "),s("li",[a._v("由先序和中序遍历序列可以还原二叉树，由后序和中序遍历序列可以还原二叉树，但由先序和后序序列不能唯一确定一棵二叉树（因为利于先序AB，后序BA，这样B既可以是A的左子树又可以是A的右子树）。")]),a._v(" "),s("li",[a._v("例子一：\n"),s("img",{staticStyle:{zoom:"80%"},attrs:{src:"C:\\Users\\hp\\AppData\\Roaming\\Typora\\typora-user-images\\image-20220211225538869.png",alt:"image-20220211225538869"}})])])]),a._v(" "),s("li",[s("p",[s("strong",[a._v("赫夫曼树及其应用")])]),a._v(" "),s("ul",[s("li",[s("mark",[a._v("待补充")])])])]),a._v(" "),s("li",[s("p",[a._v("——")])])]),a._v(" "),s("center",[s("mark",[a._v("+++++++++++++++++++++++++截止线+++++++++++++++++++++++++")])]),a._v(" "),s("h3",{attrs:{id:"字符串"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#字符串"}},[a._v("#")]),a._v(" 字符串")]),a._v(" "),s("h3",{attrs:{id:"图"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#图"}},[a._v("#")]),a._v(" 图")])],1)}),[],!1,null,null,null);t.default=e.exports}}]);