(window.webpackJsonp=window.webpackJsonp||[]).push([[53],{670:function(a,t,s){"use strict";s.r(t);var n=s(7),_=Object(n.a)({},(function(){var a=this,t=a.$createElement,s=a._self._c||t;return s("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[s("div",{staticClass:"custom-block tip"},[s("p",{staticClass:"title"}),s("p",[a._v("本章会介绍泛型基础知识，自定义泛型，几个泛型例子。")])]),a._v(" "),s("h2",{attrs:{id:"学习大致规划"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#学习大致规划"}},[a._v("#")]),a._v(" 学习大致规划：")]),a._v(" "),s("ol",[s("li",[a._v("先完成视频和笔记，有个整体认知  (2021/12/29)")]),a._v(" "),s("li",[a._v("完成第一版博客（2021/12/29）")]),a._v(" "),s("li",[a._v("后续完善博客的内容")])]),a._v(" "),s("h2",{attrs:{id:"一-泛型引入"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#一-泛型引入"}},[a._v("#")]),a._v(" 一. 泛型引入")]),a._v(" "),s("h3",{attrs:{id:"_1-注释"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-注释"}},[a._v("#")]),a._v(" (1)注释：")]),a._v(" "),s("p",[a._v("​\t\t这里主要是为什么需要引入泛型？首先是使用传统方法出现了一些局限，再通过引入泛型解决了这些问题。")]),a._v(" "),s("h3",{attrs:{id:"_2-传统方法的局限及其泛型解决方法如下"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-传统方法的局限及其泛型解决方法如下"}},[a._v("#")]),a._v(" (2)传统方法的局限及其泛型解决方法如下")]),a._v(" "),s("ol",[s("li",[s("p",[a._v("不能对加入到集合ArrayList中的数据类型进行约束(不安全)（举个例子，都是Dog类，通过遍历获取到Object类，再通过向下转型为Dog类；若是加入为Cat类型，因为没有检验会抛出异常）")]),a._v(" "),s("blockquote",[s("p",[a._v("泛型：编译的时候，检查元素的类型，提高了安全性。")])])]),a._v(" "),s("li",[s("p",[a._v("遍历的时候，需要进行类型转换，如果集合中的数据量较大，对效率有影响。")]),a._v(" "),s("blockquote",[s("p",[a._v("减少了类型转换的次数，提高了效率（可以直接拿Dog类型，而不需要类型转换）。")])])])]),a._v(" "),s("h3",{attrs:{id:"_3-泛型基础"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_3-泛型基础"}},[a._v("#")]),a._v(" (3)泛型基础")]),a._v(" "),s("ul",[s("li",[s("p",[s("u",[a._v("泛型的本质")]),a._v("是为了"),s("mark",[a._v("参数化类型")]),a._v("（在不创建新的类型的情况下，通过泛型指定的不同类型来控制形参具体限制的类型）。也就是说在泛型使用过程中，操作的数据类型被指定为一个参数，这种参数类型可以用在类、接口和方法中，分别被称为"),s("mark",[a._v("泛型类、泛型接口、泛型方法")]),a._v("。")])]),a._v(" "),s("li",[s("p",[s("u",[a._v("引入泛型的意义在于")]),a._v("：")]),a._v(" "),s("ol",[s("li",[s("p",[a._v("方便代码的复用（适合于多种数据类型执行相同的代码）；")])]),a._v(" "),s("li",[s("p",[a._v("泛型中的类型在使用时指定，不需要强制类型转换（为了类型安全）;")])]),a._v(" "),s("li",[s("p",[a._v("当泛型指定，就会约束类型，进行类型检查（避免异常的抛出）。")])])])])]),a._v(" "),s("h2",{attrs:{id:"二-泛型使用注意事项和细节"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#二-泛型使用注意事项和细节"}},[a._v("#")]),a._v(" 二.泛型使用注意事项和细节")]),a._v(" "),s("ol",[s("li",[a._v("interface List"),s("T",[a._v(" {}, public class HashSet"),s("E",[a._v(" {} 这里的T和E"),s("mark",[a._v("只能是引用数据类型，而不能是基本数据类型")]),a._v("(比如说可以是Integer而不能是int类型);")])],1)],1),a._v(" "),s("li",[a._v("("),s("mark",[a._v("?")]),a._v(")在给泛型指定具体类型后，"),s("mark",[a._v("可以传入该类型和其子类类型")]),a._v(";")]),a._v(" "),s("li",[a._v("泛型使用形式，"),s("mark",[a._v("后面那个默认简写")]),a._v("（举个例子：List"),s("Integer",[a._v(" list1 = new ArrayList<>{}）;")])],1),a._v(" "),s("li",[a._v("如果我们写成List list = new ArrayList()这里"),s("mark",[a._v("默认泛型为Object类型")]),a._v("（既可以传入任何Object类型及其子类的数据）;")]),a._v(" "),s("li",[a._v("泛型不具备继承性")]),a._v(" "),s("li",[a._v("\n<?>支持任意泛型类型\n")]),a._v(" "),s("li",[a._v("\n<? entends A>:支持A类及A类的子类，规定了泛型的上限\n")]),a._v(" "),s("li",[a._v("\n<? super A>:支持A类及A类的父类，不限于直接父类，规定了泛型的下限(起到了约束的作用)\n")])]),a._v(" "),s("h2",{attrs:{id:"三-自定义泛型"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#三-自定义泛型"}},[a._v("#")]),a._v(" 三.自定义泛型")]),a._v(" "),s("h3",{attrs:{id:"_1-自定义泛型类"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-自定义泛型类"}},[a._v("#")]),a._v(" (1)自定义泛型类")]),a._v(" "),s("ol",[s("li",[s("p",[a._v("基本语法")]),a._v(" "),s("div",{staticClass:"language-java line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-java"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("class")]),a._v(" 类名"),s("span",{pre:!0,attrs:{class:"token generics"}},[s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("<")]),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("T")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("R")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(">")])]),a._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v(" 成员 "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v("\n")])]),a._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[a._v("1")]),s("br")])])]),a._v(" "),s("li",[s("p",[a._v("普通成员(属性，方法)可以使用泛型")])]),a._v(" "),s("li",[s("p",[a._v("使用泛型的数组，不能初始化")]),a._v(" "),s("blockquote",[s("ul",[s("li",[a._v("原因：因为这个数组在new的时候，不能确定类型就无法在内存开空间，所以不允许此时初始化。")]),a._v(" "),s("li",[a._v("注意：这个hashMap却能new，需要清楚原因。")])])])]),a._v(" "),s("li",[s("p",[a._v("静态方法中不能使用类的泛型")]),a._v(" "),s("blockquote",[s("ul",[s("li",[a._v("因为静态是和类相关的，类加载时，对象还没有创建（泛型只有在对象定义时才知道是什么）。所以，如果静态方法或者静态属性使用了泛型，JVM就无法完成初始化")])])])]),a._v(" "),s("li",[s("p",[a._v("泛型类的类型，是在创建对象时确定的")]),a._v(" "),s("blockquote",[s("p",[a._v("因为创建对象时，需要指定确定类型")])])]),a._v(" "),s("li",[s("p",[a._v("如果在创建对象时，没有指定类型，默认为Object类型")])])]),a._v(" "),s("h3",{attrs:{id:"_2-自定义泛型接口"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-自定义泛型接口"}},[a._v("#")]),a._v(" (2)自定义泛型接口")]),a._v(" "),s("ol",[s("li",[s("p",[a._v("基本语法")]),a._v(" "),s("div",{staticClass:"language-java line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-java"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("interface")]),a._v(" 接口名"),s("span",{pre:!0,attrs:{class:"token generics"}},[s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("<")]),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("T")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("R")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(">")])]),a._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v("\n")])]),a._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[a._v("1")]),s("br")])])]),a._v(" "),s("li",[s("p",[a._v("接口中，静态成员也不能使用泛型")]),a._v(" "),s("blockquote",[s("p",[a._v("("),s("mark",[a._v("注意")]),a._v(")在接口中，成员都是静态性质的。")])])]),a._v(" "),s("li",[s("p",[a._v("泛型接口的类型，在继承接口或者实现接口时确定")])]),a._v(" "),s("li",[s("p",[a._v("没有指定类型，默认为Object")])])]),a._v(" "),s("h3",{attrs:{id:"_3-自定义泛型方法"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_3-自定义泛型方法"}},[a._v("#")]),a._v(" (3)自定义泛型方法")]),a._v(" "),s("ol",[s("li",[s("p",[a._v("基本语法")]),a._v(" "),s("div",{staticClass:"language-java line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-java"}},[s("code",[a._v("修饰符 "),s("span",{pre:!0,attrs:{class:"token generics"}},[s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("<")]),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("T")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("R")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(">")])]),a._v(" 返回类型 方法名"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),a._v("参数列表"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v("\n")])]),a._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[a._v("1")]),s("br")])])]),a._v(" "),s("li",[s("p",[a._v("泛型方法，可以定义在普通类中，也可以定义在泛型类中")])]),a._v(" "),s("li",[s("p",[a._v("当泛型方法调用时，传入参数，编译器就会确定类型")])]),a._v(" "),s("li",[s("p",[a._v("public void eat( E e) {}修饰符后没有<T,R,...>，这个方法不是泛型方法，而是使用了泛型")])]),a._v(" "),s("li",[s("p",[a._v("泛型方法，可以使用类声明的泛型，也可以使用自己声明泛型，根据实际情况来使用")]),a._v(" "),s("blockquote",[s("p",[a._v("("),s("mark",[a._v("注意")]),a._v(")使用类声明的泛型，需要类声明了才能使用，不然自己声明，自己不声明，就不能使用")])])])]),a._v(" "),s("h2",{attrs:{id:"四-代码示例"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#四-代码示例"}},[a._v("#")]),a._v(" 四.代码示例")]),a._v(" "),s("h3",{attrs:{id:"_1-示例一"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-示例一"}},[a._v("#")]),a._v(" (1)示例一")]),a._v(" "),s("h3",{attrs:{id:"_2-示例二"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-示例二"}},[a._v("#")]),a._v(" (2)示例二")])])}),[],!1,null,null,null);t.default=_.exports}}]);