(window.webpackJsonp=window.webpackJsonp||[]).push([[64],{673:function(_,v,t){"use strict";t.r(v);var a=t(7),i=Object(a.a)({},(function(){var _=this,v=_.$createElement,t=_._self._c||v;return t("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[t("div",{staticClass:"custom-block tip"},[t("p",{staticClass:"title"}),t("p",[_._v("这一章和其他编程语言类型，主要记住Java的特性。另外，每个类型实践几个例子，即可掌握。")])]),_._v(" "),t("h5",{attrs:{id:"_1-类就是数据类型-对象就是某个类的具体的实例。"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-类就是数据类型-对象就是某个类的具体的实例。"}},[_._v("#")]),_._v(" 1.类就是数据类型，对象就是某个类的具体的实例。")]),_._v(" "),t("blockquote",[t("ul",[t("li",[_._v("例如：可以通过猫类创建一个猫对象。")]),_._v(" "),t("li",[_._v("类是对象的模板，对象是类的一个个体，对应一个实例。")]),_._v(" "),t("li",[_._v("类是抽象的，概念的，代表一类事物，比如猫类，即它是数据类型。")]),_._v(" "),t("li",[_._v("对象是具体的，实际的，代表一个具体事物，即是实例。")])])]),_._v(" "),t("h5",{attrs:{id:"_2-java中的各种数据类型在内存中存储的方式"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-java中的各种数据类型在内存中存储的方式"}},[_._v("#")]),_._v(" 2."),t("mark",[_._v("Java中的各种数据类型在内存中存储的方式")])]),_._v(" "),t("center",[t("big",[_._v("堆内存")])],1),_._v(" "),t("blockquote",[t("ul",[t("li",[_._v("用于存放"),t("u",[_._v("由new创建的对象和数组")]),_._v("，以及"),t("u",[_._v("对象的实例变量")]),_._v("。")]),_._v(" "),t("li",[_._v("在运行时，动态地分配内存大小，一次存取速度较慢。")])])]),_._v(" "),t("center",[t("big",[_._v("栈内存")])],1),_._v(" "),t("blockquote",[t("ul",[t("li",[_._v("在函数中定义的"),t("u",[_._v("基本类型变量")]),_._v("，"),t("u",[_._v("对象的引用变量")]),_._v("都在函数的栈内存中分配")]),_._v(" "),t("li",[_._v("栈的存取速度比堆快很多，且可以数据共享。但是存取在栈中的数据大小和生存期必须确定，缺乏灵活性")])])]),_._v(" "),t("p",[t("big",[_._v("基本数据类型")])],1),_._v(" "),t("blockquote",[t("ul",[t("li",[_._v("（int，short，long，byte，float，double，boolean，char）8种")]),_._v(" "),t("li",[_._v("int a = 3分析：这里的a是一个指向int类型的引用，指向3这个字面值。这个字面值，由于大小和生存期已知，考虑到存取速度的原因，存于栈中。")]),_._v(" "),t("li",[_._v("另外，栈中的数据可以数据共享。例如：int a = 3; int b = 3;它们共同指向一个字面值为3的地址。")])])]),_._v(" "),t("p",[t("big",[_._v("对象")])],1),_._v(" "),t("blockquote",[t("ul",[t("li",[_._v("Rectange rect；声明一个对象时，将在栈内存为对象的引用变量分配内存空间。此时rect是一个空对象，它还没有引用任何实体。")]),_._v(" "),t("li",[_._v("rect = new Rectange(3, 5)：在堆内存中为类的成员变量w，h分配内存，将其初始化为各个数据类型的默认值，再是显式初始化，最后是构造器的初始化，返回堆内存对象的引用给引用变量rect。")])])]),_._v(" "),t("p",[t("big",[_._v("包装类")])],1),_._v(" "),t("blockquote",[t("ul",[t("li",[_._v("基本数据类型都有对应的包装类")]),_._v(" "),t("li",[_._v("Integer i = new Integer():  i对象引用存于栈中，i对象数据存于堆中。通过在栈中的引用来操作对象。")])])]),_._v(" "),t("p",[t("big",[_._v("String")])],1),_._v(" "),t("blockquote",[t("ul",[t("li",[_._v("String是一种特殊的包装类数据")]),_._v(" "),t("li",[_._v('有两种使用形式：①String str = new String("a, b, c")；②String str = "a, b, c"')]),_._v(" "),t("li",[_._v('String str = new String("a, b, c"):  和普通对象创建过程相同')]),_._v(" "),t("li",[_._v('String str = "a, b, c"：在栈中存取字面值“a, b, c”的地址')])])]),_._v(" "),t("p",[t("big",[_._v("数组")])],1),_._v(" "),t("blockquote",[t("ul",[t("li",[_._v("在栈内存中创建一个数组引用，通过该引用来引用数组")]),_._v(" "),t("li",[_._v("x= new int[3]：在堆内存中分配3个保存int类型数据的空间，将堆内存的首地址放到栈内存中，将每个数据元素初始化为0")])])]),_._v(" "),t("h5",{attrs:{id:"_3-对象的内容包括属性和行为。"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-对象的内容包括属性和行为。"}},[_._v("#")]),_._v(" 3.对象的内容包括"),t("mark",[_._v("属性")]),_._v("和"),t("mark",[_._v("行为")]),_._v("。")]),_._v(" "),t("blockquote",[t("ul",[t("li",[_._v("属性，也叫做成员变量。")]),_._v(" "),t("li",[_._v("行为，也叫做成员方法。")]),_._v(" "),t("li",[_._v("属性如果不赋值，有默认值。")])])]),_._v(" "),t("h5",{attrs:{id:"_4-java对象创建过程"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_4-java对象创建过程"}},[_._v("#")]),_._v(" 4."),t("mark",[_._v("Java对象创建过程")])]),_._v(" "),t("blockquote",[t("p",[_._v("假设创建一个Person对象。")]),_._v(" "),t("p",[_._v("①加载Person类信息（Person.class），注意只会加载一次；")]),_._v(" "),t("p",[_._v("②在堆中分配空间（地址）")]),_._v(" "),t("p",[_._v("③完成对象的初始化")]),_._v(" "),t("ul",[t("li",[_._v("默认初始化（数据类型的默认值）")]),_._v(" "),t("li",[_._v("显式初始化：使用类中属性提供的默认值")]),_._v(" "),t("li",[_._v("构造器的初始化")])]),_._v(" "),t("p",[_._v("④把对象在堆中的地址返回给p(p是对象名，也可以理解为对象的引用）")])]),_._v(" "),t("h5",{attrs:{id:"_5-成员方法的调用机制原理"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_5-成员方法的调用机制原理"}},[_._v("#")]),_._v(" 5.成员方法的调用机制原理:")]),_._v(" "),t("blockquote",[t("p",[_._v("①当程序执行到方法时，就会开辟一个独立的空间（栈空间）")]),_._v(" "),t("p",[_._v("②当程序执行到方法时，就会开辟一个独立的空间（栈空间）")]),_._v(" "),t("p",[_._v("③返回到调用方法的地方")]),_._v(" "),t("p",[_._v("④返回后，继续执行方法后面的代码")]),_._v(" "),t("p",[_._v("⑤当main方法（栈）执行完毕，整个程序退出")])]),_._v(" "),t("h5",{attrs:{id:"_6-成员方法的注意事项和细节"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_6-成员方法的注意事项和细节"}},[_._v("#")]),_._v(" 6.成员方法的注意事项和细节")]),_._v(" "),t("blockquote",[t("ul",[t("li",[_._v("访问修饰符：控制方法使用的范围。有四种，没写即默认。")]),_._v(" "),t("li",[_._v("返回值：一个方法最多有一个返回值，可以通过数组返回多个值。返回类型必须与要求返回数据类型一致或者兼容。")]),_._v(" "),t("li",[_._v("方法名：驼峰命名法。")]),_._v(" "),t("li",[_._v("形参列表：实参和形参的类型要一致或者兼容，个数，顺序也必须一致。")]),_._v(" "),t("li",[t("u",[_._v("方法调用细节")]),_._v("：\n"),t("ul",[t("li",[_._v("同一个类中的方法可以直接调用。")]),_._v(" "),t("li",[_._v("跨类中的方法A类调用B类方法需要通过对象名调用。")]),_._v(" "),t("li",[_._v("跨类的方法调用和方法的访问修饰符相关。")])])])])]),_._v(" "),t("h5",{attrs:{id:"_7-成员方法传参机制"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_7-成员方法传参机制"}},[_._v("#")]),_._v(" 7.成员方法传参机制")]),_._v(" "),t("blockquote",[t("ul",[t("li",[_._v("对于基本数据类型，传递的是值，形参的任何改变不影响实参。")]),_._v(" "),t("li",[_._v("对于引用数据类型，引用类型传递的是地址(地址也是值，但是值是地址)，可以通过形参影响实参。")])])]),_._v(" "),t("h5",{attrs:{id:"_8-方法重载"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_8-方法重载"}},[_._v("#")]),_._v(" 8.方法重载：")]),_._v(" "),t("blockquote",[t("ul",[t("li",[_._v("方法重载指的是Java"),t("u",[_._v("允许在同一个类中，多个同名方法的存在")]),_._v("，但是要求形参列表不一致。")]),_._v(" "),t("li",[_._v("方法重载的要求：\n"),t("ul",[t("li",[_._v("方法名字必须相同")]),_._v(" "),t("li",[_._v("形参列表必须不同(顺序，类型或者个数)，参数名无要求")]),_._v(" "),t("li",[_._v("返回类型无要求")])])])])]),_._v(" "),t("h5",{attrs:{id:"_9-可变参数"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_9-可变参数"}},[_._v("#")]),_._v(" 9.可变参数")]),_._v(" "),t("blockquote",[t("ul",[t("li",[_._v("在java5中提供了变长参数，它允许在调用方法时传入不定长度的参数。")]),_._v(" "),t("li",[_._v("变长参数是Java的一个语法糖，"),t("u",[_._v("本质上是基于数组的实现")]),_._v("。")]),_._v(" "),t("li",[_._v("在定义方法时，"),t("u",[_._v("在最后一个形参后加上三点 "),t("strong",[_._v("…")])]),_._v("，就表示该形参可以接受多个参数值，多个参数值被当成数组传入。")]),_._v(" "),t("li",[t("u",[_._v("注意事项和细节")]),_._v("：\n"),t("ul",[t("li",[_._v("可变参数的实参可以是0个或者任意多个")]),_._v(" "),t("li",[_._v("一个形参列表中只能有一个可变参数")]),_._v(" "),t("li",[_._v("可变参数可以和普通类型的参数一起放在形参列表，但是必须保证可变参数在最后")])])])])]),_._v(" "),t("h5",{attrs:{id:"_10-全局变量和局部变量"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_10-全局变量和局部变量"}},[_._v("#")]),_._v(" 10.全局变量和局部变量")]),_._v(" "),t("blockquote",[t("ul",[t("li",[_._v("全局变量一般指的是类的属性，作用域是整个类。")]),_._v(" "),t("li",[_._v("全局变量可以不赋值，直接使用，因为有默认值；")]),_._v(" "),t("li",[_._v("局部变量一般指的是成员方法中定义的变量，必须赋值后，才能使用，无默认值。")]),_._v(" "),t("li",[t("u",[_._v("作用域")]),_._v("：全局变量即属性和局部变量的作用域范围不同,"),t("u",[_._v("全局变量可以被本类使用或者其他类使用")]),_._v("。而"),t("u",[_._v("局部变量只能在本类中对应的方法中使用")]),_._v("。")]),_._v(" "),t("li",[t("u",[_._v("修饰符")]),_._v("：全局变量可以加修饰符，而局部变量不可以加修饰符。")])])]),_._v(" "),t("h5",{attrs:{id:"_11-构造器也就是构造方法-它是干嘛的"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_11-构造器也就是构造方法-它是干嘛的"}},[_._v("#")]),_._v(" 11.构造器也就是构造方法，它是干嘛的？")]),_._v(" "),t("blockquote",[t("p",[_._v("它是"),t("u",[_._v("类的一种特殊的方法")]),_._v("，它的主要作用是"),t("u",[_._v("完成对新对象的初始化")]),_._v("（不是创建对象，对象已经存在，是初始化对象）")])]),_._v(" "),t("h5",{attrs:{id:"_12-构造器有哪些特点"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_12-构造器有哪些特点"}},[_._v("#")]),_._v(" 12.构造器有哪些特点？")]),_._v(" "),t("blockquote",[t("ul",[t("li",[_._v("构造器的"),t("u",[_._v("修饰符")]),_._v("可以默认")]),_._v(" "),t("li",[_._v("它没有"),t("u",[_._v("返回值")])]),_._v(" "),t("li",[_._v("它的"),t("u",[_._v("名字")]),_._v("必须和类的名字一样")]),_._v(" "),t("li",[_._v("它的"),t("u",[_._v("参数列表")]),_._v("和成员方法规则一致")]),_._v(" "),t("li",[_._v("它的"),t("u",[_._v("调用")]),_._v("由系统自动完成")]),_._v(" "),t("li",[_._v("一个类可以定义多个不同的构造器，即"),t("u",[_._v("构造器重载")])]),_._v(" "),t("li",[_._v("若程序员没有自己定义构造器，"),t("u",[_._v("系统会自动给类生成一个默认无参构造器")]),_._v("，例如Person() {}。")]),_._v(" "),t("li",[_._v("一旦定义了自己的构造器，默认的构造器就覆盖了，就不能使用默认的无参构造器，除非显示地定义一下。")])])]),_._v(" "),t("h5",{attrs:{id:"_13-this"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_13-this"}},[_._v("#")]),_._v(" 13.this")]),_._v(" "),t("blockquote",[t("ul",[t("li",[t("p",[_._v("JVM会给每个对象分配this，用this代表当前对象>哪个对象调用，this就代表哪个对象.")])]),_._v(" "),t("li",[t("p",[_._v("this不能在类定义的外部使用，只能在类定义的方法内部使用。")]),_._v(" "),t("center",[t("big",[_._v("this的各种用法")])],1)],1),_._v(" "),t("li",[t("p",[_._v("this关键字可以用于"),t("u",[_._v("访问本类的属性和方法")])])]),_._v(" "),t("li",[t("p",[_._v("this可以用于"),t("u",[_._v("区分当前类的属性（全局变量）和局部变量")])])]),_._v(" "),t("li",[t("p",[_._v("this可以用于"),t("u",[_._v("访问本类的成员方法")]),_._v("：this.方法名（参数列表）")])]),_._v(" "),t("li",[t("p",[_._v("this可以用于"),t("u",[_._v("访问构造器")]),_._v("：this(参数列表)。("),t("u",[_._v("调用本类中另一种形式的构造函数")]),_._v("。应该为构造函数中的"),t("u",[_._v("第一条语句")]),_._v("。)")])])])]),_._v(" "),t("h4",{attrs:{id:"参考链接"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#参考链接"}},[_._v("#")]),_._v(" 参考链接:")]),_._v(" "),t("p",[_._v("1."),t("a",{attrs:{href:"https://blog.csdn.net/zj15527620802/article/details/80622314",target:"_blank",rel:"noopener noreferrer"}},[_._v("Java中的各种数据类型在内存中存储的方式"),t("OutboundLink")],1)]),_._v(" "),t("p",[_._v("2.++")])],1)}),[],!1,null,null,null);v.default=i.exports}}]);