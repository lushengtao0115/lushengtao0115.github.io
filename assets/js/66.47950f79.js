(window.webpackJsonp=window.webpackJsonp||[]).push([[66],{676:function(t,s,a){"use strict";a.r(s);var n=a(7),v=Object(n.a)({},(function(){var t=this,s=t.$createElement,a=t._self._c||s;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("div",{staticClass:"custom-block tip"},[a("p",{staticClass:"title"}),a("p",[t._v("主要内容：类变量和类方法，main方法语法，代码块，单例设计模式，final关键字，抽象类，接口，内部类")])]),t._v(" "),a("h3",{attrs:{id:"_1-类-静态-变量-类-静态-方法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-类-静态-变量-类-静态-方法"}},[t._v("#")]),t._v(" 1.类(静态)变量,类(静态)方法")]),t._v(" "),a("ul",[a("li",[a("p",[t._v("类变量，也就是静态变量；类方法，也就是静态方法；使用static修饰")])]),t._v(" "),a("li",[a("p",[t._v("类变量最大的特点是会"),a("mark",[t._v("被此类的所有的对象实例所共享")]),t._v("，也就是说，任何一个该类的对象访问它，取到的是相同的指，任何一个该类的对象去修改它，修改的也是同一个变量")])]),t._v(" "),a("li",[a("p",[t._v("类变量在类加载的时候就生成了，所以即使没有创建对象实例也可以访问")])]),t._v(" "),a("li",[a("p",[t._v("如果我们不希望创建对象实例，就可以调用某个方法，使用静态方法很方便，它可以当作工具来使用，比如Java的Math类等等")])]),t._v(" "),a("li",[a("p",[t._v("类方法不能使用和对象有关的关键字，比如super和this。因为类方法没有创建对象实例，和对象无关")])]),t._v(" "),a("li",[a("p",[t._v("("),a("mark",[t._v("重要")]),t._v(")类方法中只能访问静态变量或者静态方法,普通方法无限制")])])]),t._v(" "),a("h3",{attrs:{id:"_2-代码块"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-代码块"}},[t._v("#")]),t._v(" 2.代码块")]),t._v(" "),a("ul",[a("li",[t._v("语法： [修饰符] {代码块}   （可以不写修饰符，或者修饰符写为static。以此可以分为静态代码块和普通代码块）")]),t._v(" "),a("li",[t._v("("),a("mark",[t._v("重要")]),t._v(")不用通过对象或者类显式调用，而是加载类时，或创建对象时隐式调用")]),t._v(" "),a("li",[t._v("代码块的好处：\n"),a("ul",[a("li",[t._v("它可以看作是构造器的补充机制（如果多个构造器中都有重复的语句，可以抽取到初始代码块中，提高代码的重用性）")]),t._v(" "),a("li",[t._v("创建对象，首先会调用代码块的内容，再是调用构造器初始化")])])]),t._v(" "),a("li",[t._v("static静态代码块，可以对类进行初始化。随着"),a("u",[t._v("类的加载")]),t._v("而执行，且只会执行一次。\n"),a("ul",[a("li",[t._v("创建对象实例时new   类会被加载")]),t._v(" "),a("li",[t._v("创建子类对象实例时，父类也会被加载")]),t._v(" "),a("li",[t._v("使用类的静态成员时  类会被加载")])])]),t._v(" "),a("li",[t._v("普通代码块，每创建一个对象实例，就会执行一次。代码块是被隐式地调用。普通代码块只会在创建对象时才会被调用，和类是否加载无关。")]),t._v(" "),a("li",[t._v("("),a("mark",[t._v("重要")]),t._v(")创建一个子类对象时，调用顺序如下("),a("u",[t._v("基于两个原则去理解")]),t._v("：先进行类型加载，再是对象的创建；先调用父类，再调用子类)(通过画示意图就能很好地理解了)：\n"),a("ul",[a("li",[t._v("父类的静态代码块和静态属性")]),t._v(" "),a("li",[t._v("子类的静态代码块和静态属性")]),t._v(" "),a("li",[t._v("父类的普通代码块和普通属性")]),t._v(" "),a("li",[t._v("父类的构造方法")]),t._v(" "),a("li",[t._v("子类的普通代码块和普通属性")]),t._v(" "),a("li",[t._v("子类的构造方法")])])])]),t._v(" "),a("h3",{attrs:{id:"_3-单例设计模式"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3-单例设计模式"}},[t._v("#")]),t._v(" 3. 单例设计模式")]),t._v(" "),a("ul",[a("li",[t._v("饿汉式")]),t._v(" "),a("li",[t._v("懒汉式"),a("mark",[t._v("待弄懂")])])]),t._v(" "),a("h3",{attrs:{id:"_4-final关键字"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_4-final关键字"}},[t._v("#")]),t._v(" 4. final关键字")]),t._v(" "),a("ul",[a("li",[a("p",[a("u",[t._v("final的4种用法")]),t._v(":")]),t._v(" "),a("ol",[a("li",[t._v("类：当不希望类被继承，可以用final修饰")]),t._v(" "),a("li",[t._v("属性：当不希望类的某个属性的值被修改时，可以使用final修饰")]),t._v(" "),a("li",[t._v("方法：当不希望父类的某个方法被子类覆盖/重写（override）时，可以用final关键字修饰")]),t._v(" "),a("li",[t._v("局部变量：当不希望某个局部变量（方法中的变量）被修改，可以使用final修饰")])])]),t._v(" "),a("li",[a("p",[t._v("注意，final不能修饰构造方法")])]),t._v(" "),a("li",[a("p",[a("u",[t._v("小技巧")]),t._v("(记住，后续理解)：final static搭配使用效率更高，不会导致类的加载")])]),t._v(" "),a("li",[a("p",[t._v("包装类都是final类型，不能够被继承，例如String类")])]),t._v(" "),a("li",[a("p",[t._v("final属性在编译期间是无法确定属值的，只有运行的时候才可以确定（通过构造器初始化属性）。同样，"),a("u",[t._v("属性一经初始化后就不可以改变")]),t._v("。通过构造代码块初始化final属性也是可以的，但是这样就不能再使用构造函数初始化了，因为构造代码块必须初始化一次。")])]),t._v(" "),a("li",[a("p",[t._v("若final修饰的属性是静态的，变量就变成了常量。那么final修饰静态成员变量可以在哪些地方赋值一次呢？")]),t._v(" "),a("blockquote",[a("ol",[a("li",[t._v("定义的时候赋值一次")]),t._v(" "),a("li",[t._v("静态代码块中赋值一次")])])])])]),t._v(" "),a("h3",{attrs:{id:"_5-抽象类"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_5-抽象类"}},[t._v("#")]),t._v(" 5.抽象类")]),t._v(" "),a("ul",[a("li",[a("p",[a("u",[t._v("抽象类的价值")]),t._v("在于设计，设计者设计好后，让子类继承且实现抽象类。")])]),t._v(" "),a("li",[a("p",[t._v("抽象类不能实例化")]),t._v(" "),a("blockquote",[a("p",[t._v("那么为什么抽象类不能实例化呢？")]),t._v(" "),a("ul",[a("li",[t._v("抽象类在逻辑上无法实体化，比如买水果，买不到叫做“水果”的这种东西")]),t._v(" "),a("li",[a("mark",[t._v("??")]),t._v("因为这个类不能够被实例化，所以才设计成抽象的")]),t._v(" "),a("li",[t._v("抽象类单纯是为了继承而存在的")]),t._v(" "),a("li",[t._v("抽象类里有未实现的抽象方法，实例化时不能正常分配内存。")])])])]),t._v(" "),a("li",[a("p",[t._v("如果一个类继承了抽象类，则它必须实现抽象类的所有抽象方法，除非它自己也声明为抽象类")])]),t._v(" "),a("li",[a("p",[t._v("构造方法不能声明为抽象方法")]),t._v(" "),a("blockquote",[a("p",[a("mark",[t._v("原因？")])]),t._v(" "),a("p",[t._v("我猜测可能是构造方法作用是初始化，这样声明抽象方法就没有了方法体，无法实现构造方法的功能，与构造方法的功能相违背。")])])]),t._v(" "),a("li",[a("p",[t._v("抽象方法不能使用private，final，static来修饰")]),t._v(" "),a("blockquote",[a("p",[t._v("因为抽象类都是要被子类所重写的，因此private，final不能使用。")]),t._v(" "),a("p",[a("mark",[t._v("static原因？（类方法不能声明为抽象方法的原因）")])]),t._v(" "),a("ul",[a("li",[t._v("abstract要继承实现才可调用，static不用实例化就可以直接调用")]),t._v(" "),a("li",[a("mark",[t._v("待补充")])])])])])]),t._v(" "),a("h3",{attrs:{id:"_6-接口"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_6-接口"}},[t._v("#")]),t._v(" 6.接口")]),t._v(" "),a("ul",[a("li",[a("p",[t._v("接口是什么？")]),t._v(" "),a("blockquote",[a("p",[t._v("接口就是给出一些没有实现的方法，封装到一起，到某个类要使用的时候，再根据具体情况把这些方法写出来。")])])]),t._v(" "),a("li",[a("p",[t._v("接口中所有的方法都是public，接口中的抽象方法可以不用abstract来修饰，因为默认情况如下（void aa()       ==         public abstract void aa()）")])]),t._v(" "),a("li",[a("p",[t._v("接口中的属性只能是final的，而且是public static final修饰符  （int a=1           ==         public static final int a=1）,且必须初始化。")])]),t._v(" "),a("li",[a("p",[t._v("普通类实现接口，就必须将该接口的所有方法都实现；抽象类实现接口，可以不用实现接口的方法。")])]),t._v(" "),a("li",[a("p",[t._v("接口的修饰符和类的修饰符相同，只能是public和默认。")])]),t._v(" "),a("li",[a("p",[t._v("("),a("mark",[t._v("重要")]),t._v(")继承的价值主要在于“解决代码的复用性问题和可维护性”，实现接口是对于Java单继承机制的一种补充，接口可以实现多继承。")])]),t._v(" "),a("li",[a("p",[t._v("("),a("mark",[t._v("重要")]),t._v(")接口的一些特点小结：")]),t._v(" "),a("blockquote",[a("ul",[a("li",[t._v("接口中只能定义常量和方法（抽象方法，静态方法，默认方法，私有方法）\n"),a("ul",[a("li",[t._v("抽象方法：供子类实现")]),t._v(" "),a("li",[t._v("默认方法（有方法体的方法）：供子类调用或者子类重写")]),t._v(" "),a("li",[t._v("静态方法：供接口直接调用")]),t._v(" "),a("li",[t._v("私有方法：供接口中的默认方法或者静态方法调用")])])]),t._v(" "),a("li",[t._v("接口中不能定义成员变量和构造方法")]),t._v(" "),a("li",[t._v("接口不能创建对象，只能通过其实现类来使用")])])])]),t._v(" "),a("li",[a("p",[t._v("接口和抽象类的比较：")]),t._v(" "),a("blockquote",[a("ul",[a("li",[t._v("从用的角度来说，即设计目的：\n"),a("ul",[a("li",[t._v("接口的设计目的，是对类的行为进行约束，也就是提供一种机制，可以强制要求不同的类具有相同的行为，而不对如何实现行为进行限制。")]),t._v(" "),a("li",[t._v("抽象类的设计目的，是代码复用(在抽象类中可以写非抽象的方法，从而避免在子类中重复书写他们，这样可以提高代码的复用性，这是抽象类的优势；接口中只能有抽象的方法)。")])])]),t._v(" "),a("li",[t._v("继承是一个“是不是”的关系，而接口实现则是“有没有”的关系。如果一个类继承了某个抽象类，则子类必定是抽象类的种类，而接口实现则是有没有、具备不具备的关系，比如狗是否能钻火圈，能则可以实现这个接口，不能就不实现这个接口。")])])])])]),t._v(" "),a("h3",{attrs:{id:"_7-内部类"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_7-内部类"}},[t._v("#")]),t._v(" 7.内部类")]),t._v(" "),a("ul",[a("li",[a("p",[t._v("内部类是类的5大成员之一(属性，方法，构造器，代码块，内部类)。")])]),t._v(" "),a("li",[a("p",[t._v("内部类最大特点就是可以直接访问私有属性，并且可以体现类与类之间的包含关系。")])]),t._v(" "),a("li",[a("p",[t._v("为什么要使用内部类？")]),t._v(" "),a("blockquote",[a("ol",[a("li",[t._v("内部类方法可以访问该类定义所在的作用域中的数据 ， 包括私有的数据(即内部类可以访问自身的数据域，也可以访问创建它的外围类对象的数据域)")]),t._v(" "),a("li",[t._v("内部类可以对同一个包中的其他类隐藏起来")]),t._v(" "),a("li",[t._v("当想要定义一个回调函数且不想编写大量代码时 ， 使用匿名（ anonymous ) 内部类比较便捷")]),t._v(" "),a("li",[t._v("（使得Java的多继承机制变得更加完善）每个内部类都能独立的继承一个接口的实现，所以无论外部类是否已经继承了某个(接口的)实现，对于内部类都没有影响。内部类使得多继承的解决方案变得完整。")]),t._v(" "),a("li",[t._v("方便写事件驱动程序")])])])]),t._v(" "),a("li",[a("p",[t._v("内部类有4种：")]),t._v(" "),a("ul",[a("li",[t._v("局部内部类（有类名）（定义在外部类局部位置）")]),t._v(" "),a("li",[a("mark",[t._v("匿名内部类")]),t._v("（无类名）（定义在外部类局部位置）")]),t._v(" "),a("li",[t._v("成员内部类（无static修饰）（定义在外部类成员位置）")]),t._v(" "),a("li",[t._v("静态内部类（有static修饰）（定义在外部类成员位置）")])])]),t._v(" "),a("li",[a("p",[a("u",[t._v("局部内部类")]),t._v("：")]),t._v(" "),a("ul",[a("li",[t._v("局部内部类是定义在一个方法或者一个作用域里面的类，它和成员内部类的区别在于局部内部类的访问仅限于方法内或者该作用域内。")]),t._v(" "),a("li",[t._v("可以直接访问外部类的所有成员，包含私有的")]),t._v(" "),a("li",[t._v("它是一个局部变量：1.不能添加修饰符，可用final修饰；2.作用域仅在定义它的方法或者代码块中；3.外部其他类不能访问局部内部类")]),t._v(" "),a("li",[t._v('外部类在方法中可以创建此类的对象实例，然后调用方法，注意作用域；它可以访问外部类的成员；外部类名.this本质是外部类的对象，可以通过"外部类名.this.成员"来访问外部类的成员。')]),t._v(" "),a("li",[t._v("局部内部类一般用的很少，一般匿名内部类用的较多")])])]),t._v(" "),a("li",[a("p",[a("u",[t._v("匿名内部类")]),t._v("：")]),t._v(" "),a("ul",[a("li",[a("p",[t._v("它是编写代码使用最多的")])]),t._v(" "),a("li",[a("p",[t._v("大部分规则和“局部内部类”很相似。若某个局部内部类我们只需要使用一次，那么我们就可以使用匿名内部类。")])]),t._v(" "),a("li",[a("p",[t._v("("),a("mark",[t._v("重点")]),t._v(")本质是类，同时还是一个对象（它的语法比较奇特）。既有定义类的特征，也有创建对象的特征。"),a("u",[t._v("即有两种使用方法")]),t._v("。")]),t._v(" "),a("ol",[a("li",[t._v("Person person = new Person() {    }; person.hi();")]),t._v(" "),a("li",[t._v("new Person() {            }.hi();")])])]),t._v(" "),a("li",[a("p",[t._v("("),a("mark",[t._v("重点")]),t._v(")由于构造器的名字必须与类名相同，而匿名类没有类名，所有，匿名类不能有构造器。正"),a("u",[t._v("因为没有构造器,所以匿名内部类的使用范围非常有限，大部分匿名内部类用于接口回调")]),t._v("。匿名内部类在编译的时候由系统自动起名为 Outter$1.class。一般来说，"),a("u",[t._v("匿名内部类用于继承其他类或是实现接口，并不需要增加额外的方法，只是对继承方法的实现或是重写")]),t._v("。")])]),t._v(" "),a("li",[a("p",[t._v("匿名内部类的作用：如实现事件监听器和其他回调")]),t._v(" "),a("div",{staticClass:"language-java line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-java"}},[a("code",[a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 匿名内部类写法")]),t._v("\nscan_bt"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("setOnClickListener")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("new")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("OnClickListener")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token annotation punctuation"}},[t._v("@Override")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("public")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("void")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("onClick")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("View")]),t._v(" v"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n        "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// TODO Auto-generated method stub")]),t._v("\n         \n    "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n \nhistory_bt"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("setOnClickListener")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("new")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("OnClickListener")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n     \n    "),a("span",{pre:!0,attrs:{class:"token annotation punctuation"}},[t._v("@Override")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("public")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("void")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("onClick")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("View")]),t._v(" v"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n        "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// TODO Auto-generated method stub")]),t._v("\n         \n    "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 一般写法")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("private")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("void")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("setListener")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    scan_bt"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("setOnClickListener")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("new")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Listener1")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("       \n    history_bt"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("setOnClickListener")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("new")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Listener2")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n \n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("class")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Listener1")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("implements")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("View"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("OnClickListener")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token annotation punctuation"}},[t._v("@Override")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("public")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("void")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("onClick")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("View")]),t._v(" v"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// TODO Auto-generated method stub")]),t._v("\n             \n    "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n \n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("class")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Listener2")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("implements")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("View"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("OnClickListener")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token annotation punctuation"}},[t._v("@Override")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("public")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("void")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("onClick")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("View")]),t._v(" v"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// TODO Auto-generated method stub")]),t._v("\n             \n    "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 一般的写法冗长难以维护，匿名内部类直接继承接口，创建对象，很方便。")]),t._v("\n")])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br"),a("span",{staticClass:"line-number"},[t._v("2")]),a("br"),a("span",{staticClass:"line-number"},[t._v("3")]),a("br"),a("span",{staticClass:"line-number"},[t._v("4")]),a("br"),a("span",{staticClass:"line-number"},[t._v("5")]),a("br"),a("span",{staticClass:"line-number"},[t._v("6")]),a("br"),a("span",{staticClass:"line-number"},[t._v("7")]),a("br"),a("span",{staticClass:"line-number"},[t._v("8")]),a("br"),a("span",{staticClass:"line-number"},[t._v("9")]),a("br"),a("span",{staticClass:"line-number"},[t._v("10")]),a("br"),a("span",{staticClass:"line-number"},[t._v("11")]),a("br"),a("span",{staticClass:"line-number"},[t._v("12")]),a("br"),a("span",{staticClass:"line-number"},[t._v("13")]),a("br"),a("span",{staticClass:"line-number"},[t._v("14")]),a("br"),a("span",{staticClass:"line-number"},[t._v("15")]),a("br"),a("span",{staticClass:"line-number"},[t._v("16")]),a("br"),a("span",{staticClass:"line-number"},[t._v("17")]),a("br"),a("span",{staticClass:"line-number"},[t._v("18")]),a("br"),a("span",{staticClass:"line-number"},[t._v("19")]),a("br"),a("span",{staticClass:"line-number"},[t._v("20")]),a("br"),a("span",{staticClass:"line-number"},[t._v("21")]),a("br"),a("span",{staticClass:"line-number"},[t._v("22")]),a("br"),a("span",{staticClass:"line-number"},[t._v("23")]),a("br"),a("span",{staticClass:"line-number"},[t._v("24")]),a("br"),a("span",{staticClass:"line-number"},[t._v("25")]),a("br"),a("span",{staticClass:"line-number"},[t._v("26")]),a("br"),a("span",{staticClass:"line-number"},[t._v("27")]),a("br"),a("span",{staticClass:"line-number"},[t._v("28")]),a("br"),a("span",{staticClass:"line-number"},[t._v("29")]),a("br"),a("span",{staticClass:"line-number"},[t._v("30")]),a("br"),a("span",{staticClass:"line-number"},[t._v("31")]),a("br"),a("span",{staticClass:"line-number"},[t._v("32")]),a("br"),a("span",{staticClass:"line-number"},[t._v("33")]),a("br"),a("span",{staticClass:"line-number"},[t._v("34")]),a("br"),a("span",{staticClass:"line-number"},[t._v("35")]),a("br"),a("span",{staticClass:"line-number"},[t._v("36")]),a("br"),a("span",{staticClass:"line-number"},[t._v("37")]),a("br"),a("span",{staticClass:"line-number"},[t._v("38")]),a("br"),a("span",{staticClass:"line-number"},[t._v("39")]),a("br"),a("span",{staticClass:"line-number"},[t._v("40")]),a("br"),a("span",{staticClass:"line-number"},[t._v("41")]),a("br")])])])])]),t._v(" "),a("li",[a("p",[a("u",[t._v("成员内部类")]),t._v("：")]),t._v(" "),a("ul",[a("li",[t._v("它是类的一个成员：1.可以直接访问外部类的所有成员("),a("u",[t._v("包括private成员和静态成员")]),t._v(")；2.可以添加任意访问修饰符；3.作用域为类的整个类体；4.外部类需要先创建对象，再通过指向这个对象的引用访问成员内部类。")]),t._v(" "),a("li",[t._v("("),a("mark",[t._v("实践")]),t._v(")创建内部类对象的两种方式：\n"),a("ol",[a("li",[t._v("C.D d = c.new D()相当于内部类是它外部类的一个成员，不必纠结这只是一种语法规定")]),t._v(" "),a("li",[t._v("通过写方法，return返回一个Inner对象\n"),a("img",{attrs:{src:t.$withBase("/imgs/创建内部类对象的两种方式.jpg"),alt:"mixureSecure"}})])])]),t._v(" "),a("li",[t._v("普通内部类对象依赖于外部对象而存在，所以形成了上述创建内部类对象的两种方式。")])])]),t._v(" "),a("li",[a("p",[a("u",[t._v("静态内部类")]),t._v("：")]),t._v(" "),a("ul",[a("li",[t._v("("),a("mark",[t._v("重点")]),t._v(")可以直接访问外部类的所有静态成员，但是不能直接访问非静态成员(解释一：因为外部类加载时只会加载静态域，所有静态内部类不能使用外部类的非静态变量与方法)（解释二：静态内部类不需要依赖外部类，在没有外部类的对象的情况下，可以创建静态内部类的对象，如果允许访问外部类的非static成员就会产生矛盾，因为外部类的非static成员必须依附于具体的对象）")]),t._v(" "),a("li",[t._v("当不需要访问外部类的属性时，一般就使用静态内部类")]),t._v(" "),a("li",[t._v("可以在不创建外部类对象的情况下创建内部类的对象，静态内部类不持有指向外部类对象的引用（通过反编译文件即可得知）")])])]),t._v(" "),a("li",[a("p",[t._v("为什么成员内部类可以无条件访问外部类的成员？")]),t._v(" "),a("blockquote",[a("p",[t._v("编译器会默认为成员内部类添加一个指向外部类对象的引用。这个引用是如何赋初值的呢？编译器会默认添加一个参数，该参数的类型为指向外部类对象的一个引用，所以成员内部类中的引用就指向了外部类对象，因此可以在成员内部类中随意访问外部类的成员。")])])])]),t._v(" "),a("h3",{attrs:{id:"参考资料"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#参考资料"}},[t._v("#")]),t._v(" 参考资料")]),t._v(" "),a("ol",[a("li",[a("a",{attrs:{href:"http://www.51gjie.com/java/570.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("Java final属性"),a("OutboundLink")],1)]),t._v(" "),a("li",[a("a",{attrs:{href:"https://www.cnblogs.com/baxianhua/p/10876139.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("抽象类为什么不能实例化"),a("OutboundLink")],1)]),t._v(" "),a("li",[a("a",{attrs:{href:"https://www.zhihu.com/question/20149818",target:"_blank",rel:"noopener noreferrer"}},[t._v("接口和抽象类有什么区别 -- 知乎问答"),a("OutboundLink")],1)]),t._v(" "),a("li",[t._v("Java核心技术卷一")]),t._v(" "),a("li",[a("a",{attrs:{href:"https://www.runoob.com/w3cnote/java-inner-class-intro.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("Java内部类详解"),a("OutboundLink")],1)]),t._v(" "),a("li",[a("a",{attrs:{href:"https://www.cnblogs.com/libinhong/p/10990347.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("Java中的接口详解"),a("OutboundLink")],1)]),t._v(" "),a("li",[a("a",{attrs:{href:"https://bbs.csdn.net/topics/320013307",target:"_blank",rel:"noopener noreferrer"}},[t._v("对于“为何静态方法不能同时声明为抽象方法”的讨论"),a("OutboundLink")],1)])])])}),[],!1,null,null,null);s.default=v.exports}}]);