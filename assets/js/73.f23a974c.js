(window.webpackJsonp=window.webpackJsonp||[]).push([[73],{685:function(v,_,l){"use strict";l.r(_);var i=l(7),p=Object(i.a)({},(function(){var v=this,_=v.$createElement,l=v._self._c||_;return l("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[l("div",{staticClass:"custom-block tip"},[l("p",{staticClass:"title"}),l("p",[v._v("这里是对于Java基础知识的整理，主要来自于《head java first》，还有一些博客上面内容的整理。")])]),v._v(" "),l("ul",[l("li",[l("p",[v._v("一个程序只需要一个main来运行（Java程序是用一组类所组成，其中有一个类会带有启动用的main()方法）")])]),v._v(" "),l("li",[l("p",[v._v("覆盖override的意思是由子类重新定义继承下来的方法，以改变或者延申此方法的行为")])]),v._v(" "),l("li",[l("p",[v._v("对象")]),v._v(" "),l("ul",[l("li",[l("p",[v._v("对象本身已知的事物被称为实例变量（状态）")])]),v._v(" "),l("li",[l("p",[v._v("对象可以执行的动作被称为方法（行为）")])])])]),v._v(" "),l("li",[l("p",[v._v("类和对象的区别")]),v._v(" "),l("ul",[l("li",[l("p",[v._v("类会告诉虚拟机如何创建某种类型的对象")])]),v._v(" "),l("li",[l("p",[v._v("根据某类创建出来的对象都会由自己的实例变量")])])])]),v._v(" "),l("li",[l("p",[v._v("真正的java程序只会让对象与对象交互（相互调用方法）")])]),v._v(" "),l("li",[l("p",[v._v("对象变量？")]),v._v(" "),l("ul",[l("li",[l("p",[v._v("没有对象变量，只有对象引用变量")])]),v._v(" "),l("li",[l("p",[v._v("对象引用变量保存的是存取对象的方法（它并不是对象的容器，而是类似于指向对象的指针）")])])])]),v._v(" "),l("li",[l("p",[v._v("数组")]),v._v(" "),l("ul",[l("li",[l("p",[v._v("数组本身是对象")])]),v._v(" "),l("li",[l("p",[v._v("一旦数组被声明出来，你就只能装入所声明类型的元素")])]),v._v(" "),l("li",[l("p",[v._v("对数组的操作可以不需要使用变量名称，只需要数组索引")])])])]),v._v(" "),l("li",[l("p",[v._v("方法参数")]),v._v(" "),l("ul",[l("li",[v._v("如果方法有参数，你一定要以正确数量，类型和顺序来传入参数")])])]),v._v(" "),l("li",[l("p",[v._v("实例变量于局部变量的差别")]),v._v(" "),l("ul",[l("li",[v._v("实例变量声明在类内，有默认值；局部变量声明在方法中，，在使用前必须初始化，没有默认值")])])]),v._v(" "),l("li",[l("p",[v._v("==运算符和equals()方法区别")]),v._v(" "),l("ul",[l("li",[l("p",[v._v("==判断两个引用是否指向同一对象")])]),v._v(" "),l("li",[l("p",[v._v("equals比较两个对象在意义上是否相等（即不需要指向同一对象）")])])])]),v._v(" "),l("li",[l("p",[l("u",[v._v("继承下来的方法可以被覆盖掉，但是实例变量不能被覆盖掉")]),v._v("。")])]),v._v(" "),l("li",[l("p",[v._v("Java程序只是由一堆类组成的，因此，子类不需要重新编译就能运用到新版本的父类")])]),v._v(" "),l("li",[l("p",[v._v("伪码，测试码和真实码")]),v._v(" "),l("ul",[l("li",[l("p",[v._v("伪码：节约时间，文档的效果，对于复杂程序有必要（注意伪码应该描述要做i什么事情而不是如何做）")])]),v._v(" "),l("li",[l("p",[v._v("测试码：这是单独写好的一些类或者方法，通过调用一些写好的类和方法，输入一些数据，测试")])])])]),v._v(" "),l("li",[l("p",[v._v("java中的循环")]),v._v(" "),l("ol",[l("li",[l("p",[v._v("基础for循环："),l("br"),v._v(" "),l("img",{attrs:{src:v.$withBase("/imgs/java的for循环语法格式.PNG"),alt:"mixureSecure"}})])]),v._v(" "),l("li",[l("p",[v._v("加强版for循环：\n这主要是用于数组的增强型for循环。"),l("br"),v._v("\nJava增强for循环语法格式如下："),l("br"),v._v(" "),l("img",{attrs:{src:v.$withBase("/imgs/Java增强for循环语法格式.PNG"),alt:"mixureSecure"}}),l("br"),v._v("\n实例：")]),v._v(" "),l("img",{attrs:{src:v.$withBase("/imgs/Java增强for循环实例.PNG"),alt:"mixureSecure"}})])])]),v._v(" "),l("li",[l("p",[v._v("当我们调用对象引用方法的时候，我们会调用到与该对象类型最接近的方法，也就是说：最低阶的会胜出（即先从层次树的最下方开始找，没找到再依次向上，直到找到为止）。")])]),v._v(" "),l("li",[l("p",[v._v("引用类型与对象的类型必须相符，但是在"),l("mark",[v._v("多态")]),v._v("下,引用与对象可以是不同的类型。"),l("br"),v._v("\n例如：Animal myDog() = new Dog()."),l("br"),v._v("\n原因：这是因为运用多态时，"),l("u",[v._v("引用类型可以是实际对象类型的父类")]),v._v("。"),l("br"),v._v("\n拓展： 参数和返回类型也可以多态（"),l("u",[v._v("使用多态参数")]),v._v("：将参数声明成父类类型，我就可以在运行时传入任何的子类对象）。")])]),v._v(" "),l("li",[l("p",[v._v("防止某个类被作为子类的三种方法：")]),v._v(" "),l("ol",[l("li",[l("p",[v._v("存取控制：可以不标记为公有，而"),l("u",[v._v("非公有的类只能被同一个包的类作为子类")]),v._v("。")])]),v._v(" "),l("li",[l("p",[v._v("final修饰符：这表示它是继承树的末端，不能被继承。")])]),v._v(" "),l("li",[l("p",[v._v("让类只拥有private的构造程序。")])])])]),v._v(" "),l("li",[l("p",[v._v("方法覆盖的规则：")]),v._v(" "),l("ol",[l("li",[l("p",[v._v("参数必须要一样")])]),v._v(" "),l("li",[l("p",[v._v("返回类型必须要兼容（子类必须要声明返回一样的类型或者该类型的子型）")])]),v._v(" "),l("li",[l("p",[v._v("不能降低方法的存取权限（一样或者更加开放）")])])])]),v._v(" "),l("li",[l("p",[v._v("方法重载：")]),v._v(" "),l("ul",[l("li",[l("p",[v._v("重载的意义：两个方法名称相同，但是参数必须不同")])]),v._v(" "),l("li",[l("p",[v._v("重载与多态毫无关系")])]),v._v(" "),l("li",[l("p",[v._v("重载可以有同一方法的多个不同参数版本以方便调用")])]),v._v(" "),l("li",[l("p",[v._v("返回类型可以不同")])]),v._v(" "),l("li",[l("p",[v._v("参数必须不同！！！")])]),v._v(" "),l("li",[l("p",[v._v("可以更改存取权限")])])])]),v._v(" "),l("li",[l("p",[v._v("抽象类：")]),v._v(" "),l("ul",[l("li",[l("p",[v._v("抽象类代表"),l("u",[v._v("没有人能够创建出该类的实例")]),v._v("(无法实例化)")])]),v._v(" "),l("li",[l("p",[v._v("抽象类除了"),l("u",[v._v("被继承")]),v._v("之外，是没有用途，没有值，没有目的。")])]),v._v(" "),l("li",[l("p",[v._v("我们可以强迫子类实现抽象类的抽象方法")])]),v._v(" "),l("li",[l("p",[v._v("抽象方法实际上相当于定义了“规范”")])]),v._v(" "),l("li",[l("p",[v._v("合理设计抽象类和接口，可以充分地复用代码")])])])]),v._v(" "),l("li",[l("p",[v._v("抽象方法")]),v._v(" "),l("ul",[l("li",[l("p",[v._v("抽象的方法没有实体，例如："),l("java",[v._v("public abstract void eat()")])],1)]),v._v(" "),l("li",[l("p",[v._v("如果我们声明出一个抽象的方法，就必须将类也标记为抽象的")])]),v._v(" "),l("li",[l("p",[l("u",[v._v("抽象方法的意义")]),v._v("：就算无法实现出方法的内容，也可以"),l("u",[v._v("定义出一组子型共同的协议")]),v._v("。这样做的好处是："),l("u",[v._v("多态")]),v._v(",多态的好处在于所有子型都会有那些抽象的方法。"),l("mark",[v._v("这里没有完全理解！！！")]),v._v("mark>")])]),v._v(" "),l("li",[l("p",[v._v("抽象的方法没有内容，它是为了标记出多态而存在。")])]),v._v(" "),l("li",[l("p",[v._v("必须实现所有抽象的方法（Java很注重你的具体子类有没有实现这些方法）"),l("mark",[v._v("没有理解！！！")])])])])]),v._v(" "),l("li",[l("p",[v._v("从ArrayList"),l("Object",[v._v("取出的Object都会被当作是Object这个类的实例，编译器无法将此对象识别为Object以外的事物")])],1),v._v(" "),l("ul",[l("li",[v._v("可以赋值任何东西给Object类型的引用，但是不能将Object赋值给Dog类型的引用；")]),v._v(" "),l("li",[v._v("当一个对象被声明为Object类型的对象所引用时，它无法再赋值给原来类型的变量；")]),v._v(" "),l("li",[v._v("编译器是"),l("mark",[v._v("根据引用类型来判断有哪些method可以调用")]),v._v("mark>，而不是根据Object确定的类型("),l("u",[v._v("例如")]),v._v("：如果对象的类型是Snowboard，而引用它的却是Object，则它不能调用Snowboard的方法)。")]),v._v(" "),l("li",[l("u",[v._v("转换为原来的类型")]),v._v("：Dog d= (Dog) o,也可以事先判断它是不是Dog类型。")])])]),v._v(" "),l("li",[l("p",[v._v("接口")]),v._v(" "),l("ul",[l("li",[l("p",[l("mark",[v._v("接口可以解决多重继承问题")]),v._v("mark>而不至于出现致命方块问题（Java不允许多重继承，因为那样会出现致命方块的问题）")])]),v._v(" "),l("li",[l("p",[v._v("接口为什么可以解决多重继承问题？（"),l("mark",[v._v("没有懂")]),v._v("）")])]),v._v(" "),l("li",[l("p",[v._v("接口就好像是"),l("mark",[v._v("纯抽象类")]),v._v("，所有的接口的方法都是抽象的，所以任何类都必须要实现这些方法。")])]),v._v(" "),l("li",[l("p",[v._v("接口的定义：public"),l("u",[v._v(" interface")]),v._v(" Pet {...}")])]),v._v(" "),l("li",[l("p",[v._v("接口的实现：public class Dog extends Canine "),l("u",[v._v("implements")]),v._v(" Pet {...}  (实现的接口必须要在某个类的继承之下)。")])]),v._v(" "),l("li",[l("p",[v._v("使用接口就可以继承超过一个以上的来源")])]),v._v(" "),l("li",[l("p",[v._v("类可以实现多个接口")])]),v._v(" "),l("li",[l("p",[v._v("当用接口作为多态类型时，对象可以来自任何地方（"),l("u",[v._v("只要该对象来自有实现此接口的类")]),v._v("）")])])])]),v._v(" "),l("li",[l("p",[v._v("实例变量与局部变量")]),v._v(" "),l("ul",[l("li",[l("p",[v._v("实例变量是被声明在类而不是方法里面，他们代表每个独立对象的”字段“（实例变量存在于所属的对象里）（实例变量存在于对象所属的堆空间上）")])]),v._v(" "),l("li",[l("p",[v._v("局部变量和方法的参数都是被声明在方法里的，它们是暂时的，且生命周期只限于方法被放在栈上的这段期间（也就是方法调用至执行完毕为止）")])])])]),v._v(" "),l("li",[l("p",[v._v("构造函数")]),v._v(" "),l("ul",[l("li",[v._v("构造函数并不是方法")]),v._v(" "),l("li",[v._v("唯一能够调用构造函数的办法打就是"),l("u",[v._v("新建一个类")])]),v._v(" "),l("li",[v._v("构造函数带有你在"),l("u",[v._v("初始化对象时会执行的程序代码")])]),v._v(" "),l("li",[v._v("构造函数"),l("mark",[v._v("无返回类型")]),v._v(",它的名称与类的名称相同")]),v._v(" "),l("li",[v._v("构造函数不会被继承")]),v._v(" "),l("li",[v._v("如果我们在创建对象时，需要有程序代码帮忙初始化，就得自己编写构造函数("),l("mark",[v._v("没有看懂")]),v._v(")")]),v._v(" "),l("li",[v._v("①如果你没有写构造函数，编译器就会帮你写一个无参数的构造函数；②如果你已经写了一个有参数的构造函数，则编译器就不会再帮你写一个无参数的构造函数；③如果类有一个以上的构造函数，则参数必须不一样")]),v._v(" "),l("li",[l("mark",[l("u",[v._v("重点")])]),v._v(":在创建新对象时，所有继承下来的构造函数都会执行（"),l("u",[v._v("原因")]),v._v(":每个类至少有一个构造函数，且"),l("u",[v._v("每个构造函数都会在子类对象创建时期执行")]),v._v("）。")]),v._v(" "),l("li",[v._v("如何调用父类的构造函数：\n"),l("ul",[l("li",[l("mark",[v._v("重点")]),v._v(":在我们的构造函数中调用super()会把父类的构造函数放在堆栈的最上方，父类的构造函数会调用它的父类构造函数，接着会一路上直到Object的构造函数为止("),l("u",[v._v("一层一层地调用")]),v._v(");然后一路执行，弹回到原来的构造函数。")]),v._v(" "),l("li",[v._v("如果我们没有调用super(),"),l("u",[v._v("编译器会帮助我们调用无参数的·super()方法")]),v._v("。")]),v._v(" "),l("li",[l("mark",[v._v("对于super()的调用必须是构造函数的第一个语句")])])])]),v._v(" "),l("li",[v._v("从某个构造函数调用"),l("u",[v._v("重载版")]),v._v("的另一个构造函数：\n"),l("ul",[l("li",[v._v("每个构造函数可以选择调用this()或者super().但是不能同时调用")]),v._v(" "),l("li",[v._v("this()可以调用同一类的另外一个构造函数，且必须是第一行语句")])])])])]),v._v(" "),l("li",[l("p",[v._v("静态方法 vs 非静态方法")]),v._v(" "),l("ul",[l("li",[v._v("静态方法\n"),l("ul",[l("li",[v._v("在外部调用静态方法的方式：类别.方法名，对象名.方法名。（"),l("mark",[v._v("调用静态方法可以无需创建对象")]),v._v("）。")]),v._v(" "),l("li",[v._v("静态方法在访问本类的成员时，只允许访问静态成员（静态成员变量和静态方法），不允许访问实例成员变量和实例方法")]),v._v(" "),l("li",[v._v("main()方法是一个典型的静态方法，所以它可以由系统在创建对象之前就调用")]),v._v(" "),l("li",[v._v("static可以标志出不需要实例的方法")])])]),v._v(" "),l("li",[v._v("静态变量：\n"),l("ul",[l("li",[v._v("它的值对于所有的实例来说都相同（静态变量的作用是被同类的所有实例共享的变量）")]),v._v(" "),l("li",[v._v("静态变量是在类被加载时初始化的（静态变量会在该类的任何静态方法之前就被初始化）")]),v._v(" "),l("li",[v._v("若我们没有给静态变量赋初值，那么他就会被设定默认值（该变量类型的默认值）")])])]),v._v(" "),l("li",[v._v("非静态方法（实例方法）\n"),l("ul",[l("li",[l("p",[v._v("在外部调用静态方法的方式：对象名.方法名。")])]),v._v(" "),l("li",[l("p",[v._v("实例方法在访问本类的成员时，无限制")])])])])])])])])}),[],!1,null,null,null);_.default=p.exports}}]);