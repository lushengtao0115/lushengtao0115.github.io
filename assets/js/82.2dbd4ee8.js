(window.webpackJsonp=window.webpackJsonp||[]).push([[82],{712:function(v,_,t){"use strict";t.r(_);var a=t(7),r=Object(a.a)({},(function(){var v=this,_=v.$createElement,t=v._self._c||_;return t("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[t("p",[t("strong",[v._v("面向对象设计原则概述")])]),v._v(" "),t("ul",[t("li",[t("p",[v._v("如何同时提高一个软件系统的可维护性和可复用性是面向对象设计需要解决的核心问题之一。")])]),v._v(" "),t("li",[t("p",[v._v("在面向对象设计中，"),t("u",[v._v("可维护性的复用是以设计原则为基础的")]),v._v("。")])]),v._v(" "),t("li",[t("p",[v._v("每一个设计原则都蕴含了一些面向对象设计的思想。")])]),v._v(" "),t("li",[t("p",[v._v("面向对象设计原则为支持可维护性复用而诞生，这些原则蕴含在很多设计模式中，它们是从许多设计方案中总结出的指导性原则。")])]),v._v(" "),t("li",[t("p",[v._v("7种常用的面向对象设计原则：")]),v._v(" "),t("center",[t("img",{staticStyle:{zoom:"75%"},attrs:{src:"C:\\Users\\hp\\AppData\\Roaming\\Typora\\typora-user-images\\image-20220223090209799.png",alt:"image-20220223090209799"}})])],1)]),v._v(" "),t("p",[t("strong",[v._v("第一种：单一职责原则")])]),v._v(" "),t("ul",[t("li",[t("p",[v._v("最简单最难应用")])]),v._v(" "),t("li",[t("p",[v._v("单一职责原则："),t("strong",[v._v("一个类只负责一个功能领域中的相应职责，或者可以定义为：就一个类而言，应该只有一个引起它变化的原因。")])])]),v._v(" "),t("li",[t("p",[v._v("一个类承担的职责越多，复用的可能性就越小，耦合度高。")])]),v._v(" "),t("li",[t("p",[v._v("单一职责原则是实现"),t("strong",[v._v("高内聚、低耦合")]),v._v("的指导方针，它是最简单但又最难运用的原则，需要设计人员发现类的不同职责并将其分离，而发现类的多重职责需要设计人员具有较强的分析设计能力和相关实践经验。")])]),v._v(" "),t("li",[t("p",[t("mark",[v._v("一个实例图")]),v._v("：\n"),t("img",{staticStyle:{zoom:"67%"},attrs:{src:"C:\\Users\\hp\\AppData\\Roaming\\Typora\\typora-user-images\\image-20220224132009115.png",alt:"image-20220224132009115"}})]),v._v(" "),t("img",{staticStyle:{zoom:"67%"},attrs:{src:"C:\\Users\\hp\\AppData\\Roaming\\Typora\\typora-user-images\\image-20220224132036717.png",alt:"image-20220224132036717"}})])]),v._v(" "),t("p",[t("strong",[v._v("第二种：开闭原则")])]),v._v(" "),t("ul",[t("li",[t("p",[v._v("最重要的面向对象设计原则")])]),v._v(" "),t("li",[t("p",[v._v("开闭原则："),t("strong",[v._v("一个软件实体应当对扩展开放，对修改关闭。即软件实体应尽量在不修改原有代码的情况下进行扩展")]),v._v("。")])]),v._v(" "),t("li",[t("p",[v._v("当软件系统需要面对新的需求时，我们应该尽量保证系统的设计框架是稳定的。如果一个软件设计符合开闭原则，那么可以非常方便地对系统进行扩展，而且在扩展时无须修改现有代码，使得软件系统在拥有适应性和灵活性的同时具备较好的稳定性和延续性。")])]),v._v(" "),t("li",[t("p",[v._v("在Java语言中。为了满足开闭原则，需要对系统进行抽象化设计，抽象化是开闭原则的关键。Java中，"),t("u",[v._v("可以为系统定义一个相对稳定的抽象层，而将不同的实现行为移至具体的实现层中完成")]),v._v("。可以通过它们定义系统的抽象层，再通过具体类来进行扩展。如果需要修改系统的行为，无须对抽象层进行任何改动，只需要增加新的具体类来实现新的业务功能即可，实现在不修改已有代码的基础上扩展系统的功能，达到开闭原则的要求。")])]),v._v(" "),t("li",[t("p",[t("mark",[v._v("一个实例（体现开闭原则）")]),v._v("：\n引入抽象图表类AbstractChart。即定义一个抽象层，不修改底层源码，而由客户端来设置，xml和properties等格式的配置文件。这里可以"),t("mark",[v._v("参照IOC那个简化原型")]),v._v("。\n"),t("img",{staticStyle:{zoom:"67%"},attrs:{src:"C:\\Users\\hp\\AppData\\Roaming\\Typora\\typora-user-images\\image-20220224133840366.png",alt:"image-20220224133840366"}})]),v._v(" "),t("img",{staticStyle:{zoom:"67%"},attrs:{src:"C:\\Users\\hp\\AppData\\Roaming\\Typora\\typora-user-images\\image-20220224133904509.png",alt:"image-20220224133904509"}})])]),v._v(" "),t("p",[t("strong",[v._v("第三种：里氏代换原则")])]),v._v(" "),t("ul",[t("li",[t("p",[v._v("里氏代换原则："),t("strong",[v._v("所有引用基类（父类）的地方必须能透明地使用其子类的对象。")])])]),v._v(" "),t("li",[t("p",[v._v("里氏代换原则告诉我们，"),t("u",[v._v("在软件中将一个基类对象替换成它的子类对象，程序将不会产生任何错误和异常，反过来则不成立，如果一个软件实体使用的是一个子类对象的话，那么它不一定能够使用基类对象。")])])]),v._v(" "),t("li",[t("p",[v._v("里氏代换原则是实现开闭原则的重要方式之一，由于使用基类对象的地方都可以使用子类对象，因此"),t("u",[v._v("在程序中尽量使用基类类型来对对象进行定义，而在运行时再确定其子类类型，用子类对象来替换父类对象")]),v._v("。")])]),v._v(" "),t("li",[t("p",[v._v("使用里氏代换原则需要注意以下几个问题：")]),v._v(" "),t("ul",[t("li",[v._v("子类的所有方法必须在父类中声明，或子类必须实现父类中声明的所有方法。若一个方法只存在子类中，在父类中不提供相应的声明，则无法在以父类定义的对象中使用该方法。")]),v._v(" "),t("li",[v._v("我们在运用里氏代换原则时，尽量把父类设计为抽象类或者接口，让子类继承父类或实现父接口，并实现在父类中声明的方法，运行时，子类实例替换父类实例，我们可以很方便地扩展系统的功能，同时无须修改原有子类的代码，增加新的功能可以通过增加一个新的子类来实现。里氏代换原则是开闭原则的具体实现手段之一。")])])]),v._v(" "),t("li",[t("p",[t("mark",[v._v("一个实例（体现里氏代换原则）")]),v._v("：")]),v._v(" "),t("p",[v._v("​\t\t在Sunny软件公司开发的CRM系统中，客户(Customer)可以分为VIP客户(VIPCustomer)和普通客户(CommonCustomer)两类，系统需要提供一个发送Email的功能。无论是普通客户还是VIP客户，发送邮件的过程都是相同的，也就是说两个send()方法中的代码重复，而且在本系统中还将增加新类型的客户。为了让系统具有更好的扩展性，同时减少代码重复，使用里氏代换原则对其进行重构。")]),v._v(" "),t("p",[v._v("​\t\t在本实例中，可以考虑增加一个新的抽象客户类Customer，而将CommonCustomer和VIPCustomer类作为其子类，"),t("u",[v._v("邮件发送类EmailSender类针对抽象客户类Customer编程，根据里氏代换原则，能够接受基类对象的地方必然能够接受子类对象，因此将EmailSender中的send()方法的参数类型改为Customer")]),v._v("，如果需要增加新类型的客户，只需将其作为Customer类的子类即可。\n"),t("img",{staticStyle:{zoom:"67%"},attrs:{src:"C:\\Users\\hp\\AppData\\Roaming\\Typora\\typora-user-images\\image-20220224141500900.png",alt:"image-20220224141500900"}})]),v._v(" "),t("img",{staticStyle:{zoom:"67%"},attrs:{src:"C:\\Users\\hp\\AppData\\Roaming\\Typora\\typora-user-images\\image-20220224141412858.png",alt:"image-20220224141412858"}})])]),v._v(" "),t("p",[t("strong",[v._v("第四种：依赖倒转原则")])]),v._v(" "),t("ul",[t("li",[t("p",[v._v("如果说开闭原则是面向对象设计的目标的话，那么"),t("u",[v._v("依赖倒转原则就是面向对象设计的主要实现机制之一，它是系统抽象化的具体实现")]),v._v("。")])]),v._v(" "),t("li",[t("p",[v._v("依赖倒转原则："),t("strong",[v._v("抽象不应该依赖于细节，细节应当依赖于抽象。换言之，要针对接口编程，而不是针对实现编程")]),v._v("。")])]),v._v(" "),t("li",[t("p",[v._v("依赖倒转原则要求我们在程序代码中传递参数时或在关联关系中，尽量引用层次高的抽象层类，即使用接口和抽象类进行变量类型声明、参数类型声明、方法返回类型声明，以及数据类型的转换等，而不要用具体类来做这些事情。")])]),v._v(" "),t("li",[t("p",[v._v("在引入抽象层后，系统将具有很好的灵活性，"),t("u",[v._v("在程序中尽量使用抽象层进行编程，而将具体类写在配置文件中")]),v._v("，这样一来，"),t("u",[v._v("如果系统行为发生变化，只需要对抽象层进行扩展，并修改配置文件，而无须修改原有系统的源代码")]),v._v("，在不修改的情况下来扩展系统的功能，满足开闭原则的要求。")])]),v._v(" "),t("li",[t("p",[v._v("在实现依赖倒转原则时，我们需要针对抽象层编程，而将具体类的对象通过依赖注入(DependencyInjection, DI)的方式注入到其他对象中，依赖注入是指当一个对象要与其他对象发生依赖关系时，通过抽象来注入所依赖的对象。")])]),v._v(" "),t("li",[t("p",[t("mark",[v._v("一个实例")]),v._v(":")]),v._v(" "),t("p",[v._v("​\t\t这里的依赖倒转主要是指针对接口（利用抽象层）编程，而不是针对实现编程，而将具体类写在配置文件中。")]),v._v(" "),t("p",[v._v("​\t\t系统经常需要将存储在TXT或Excel文件中的客户信息转存到数据库中，因此需要进行数据格式转换。在客户数据操作类CustomerDAO中将调用数据格式转换类的方法实现格式转换和数据库插入操作。\n"),t("img",{staticStyle:{zoom:"67%"},attrs:{src:"C:\\Users\\hp\\AppData\\Roaming\\Typora\\typora-user-images\\image-20220224144231173.png",alt:"image-20220224144231173"}})]),v._v(" "),t("p",[v._v("​\t\t这个方法存在严重的问题："),t("u",[v._v("由于每次转换数据时数据来源不一定相同，因此需要更换数据转换类")]),v._v("。如有时候需要将TXTDataConvertor改为ExcelDataConvertor，此时，"),t("u",[v._v("需要修改CustomerDAO的源代码")]),v._v("，而且在引入并使用新的数据转换类时也不得不修改CustomerDAO的源代码，系统扩展性较差，违反了开闭原则，现需要对该方案进行重构。")]),v._v(" "),t("p",[v._v("​\t\t由于CustomerDAO针对具体数据转换类编程，因此在增加新的数据转换类或者更换数据转换类时都不得不修改CustomerDAO的源代码。我们"),t("u",[v._v("可以通过引入抽象数据转换类解决该问题")]),v._v("。")]),v._v(" "),t("p",[v._v("​\t\t在引入抽象数据转换类DataConvertor之后，"),t("u",[v._v("CustomerDAO针对抽象类DataConvertor编程，而将具体数据转换类名存储在配置文件中，符合依赖倒转原则")]),v._v("。"),t("u",[v._v("根据里氏代换原则，程序运行时，具体数据转换类对象将替换DataConvertor类型的对象，程序不会出现任何问题")]),v._v("。更换具体数据转换类时无须修改源代码，只需要修改配置文件；如果需要增加新的具体数据转换类，只要将新增数据转换类作为DataConvertor的子类并修改配置文件即可，原有代码无须做任何修改，"),t("u",[v._v("满足开闭原则")]),v._v("。重构后的结构如下图：\n"),t("img",{staticStyle:{zoom:"80%"},attrs:{src:"C:\\Users\\hp\\AppData\\Roaming\\Typora\\typora-user-images\\image-20220224150109718.png",alt:"image-20220224150109718"}})]),v._v(" "),t("p",[v._v("​\t\t"),t("mark",[v._v("注意")]),v._v("： 在上述重构过程中，我们使用了开闭原则、里氏代换原则和依赖倒转原则，在大多数情况下，这三个设计原则会同时出现，"),t("strong",[v._v("开闭原则是目标，里氏代换原则是基础，依赖倒转原则是手段")]),v._v("，它们相辅相成，相互补充，目标一致，只是分析问题时所站角度不同而已。")])])]),v._v(" "),t("p",[t("strong",[v._v("第五种：接口隔离原则")])]),v._v(" "),t("ul",[t("li",[v._v("接口隔离原则："),t("strong",[v._v("使用多个专门的接口，而不使用单一的总接口，即客户端不应该依赖那些它不需要的接口。")])]),v._v(" "),t("li",[v._v("每一个接口应该承担一种相对独立的角色，不干不该干的事，该干的事都要干。")]),v._v(" "),t("li",[t("u",[v._v("在使用接口隔离原则时，我们需要注意控制接口的粒度，接口不能太小，如果太小会导致系统中接口泛滥，不利于维护；接口也不能太大，太大的接口将违背接口隔离原则，灵活性较差，使用起来很不方便")]),v._v("。一般而言，接口中仅包含为某一类用户定制的方法即可，不应该强迫客户依赖于那些它们不用的方法。")])]),v._v(" "),t("p",[t("strong",[v._v("第六种：合成复用原则")])]),v._v(" "),t("ul",[t("li",[t("p",[v._v("合成复用原则："),t("strong",[v._v("尽量使用对象组合，而不是继承来达到复用的目的。")])])]),v._v(" "),t("li",[t("p",[v._v("合成复用原则就是在一个新的对象里通过关联关系（包括组合关系和聚合关系）来使用一些已有的对象，使之成为新对象的一部分；新对象通过委派调用已有对象的方法达到复用功能的目的。简言之：复用时要尽量使用组合聚合关系（关联关系），少用继承。")])]),v._v(" "),t("li",[t("p",[v._v("在面向对象设计中，"),t("u",[v._v("可以通过两种方法在不同的环境中复用已有的设计和实现，即通过组合/聚合关系或通过继承")]),v._v("，但首先应该考虑使用组合/聚合，组合/聚合可以使系统更加灵活，降低类与类之间的耦合度，一个类的变化对其他类造成的影响相对较少；其次才考虑继承，在使用继承时，需要严格遵循里氏代换原则，有效使用继承会有助于对问题的理解，降低复杂度，而"),t("u",[v._v("滥用继承反而会增加系统构建和维护的难度以及系统的复杂度，因此需要慎重使用继承复用")]),v._v("。")])]),v._v(" "),t("li",[t("p",[t("u",[v._v("通过继承来进行复用的主要问题在于继承复用会破坏系统的封装性，因为继承会将基类的实现细节暴露给子类")]),v._v("，由于基类的内部细节通常对子类来说是可见的，所以这种复用又称“白箱”复用，如果基类发生改变，那么子类的实现也不得不发生改变；"),t("u",[v._v("从基类继承而来的实现是静态的，不可能在运行时发生改变，没有足够的灵活性")]),v._v("；而且继承只能在有限的环境中使用（如类没有声明为不能被继承）。")])]),v._v(" "),t("li",[t("p",[t("u",[v._v("使用对象组合的原因")]),v._v("：由于组合或聚合关系可以将已有的对象（也可称为成员对象）纳入到新对象中，使之成为新对象的一部分，因此新对象可以调用已有对象的功能，"),t("u",[v._v("这样做可以使得成员对象的内部实现细节对于新对象不可见，所以这种复用又称为“黑箱”复用")]),v._v("，相对继承关系而言，其"),t("u",[v._v("耦合度相对较低，成员对象的变化对新对象的影响不大")]),v._v("，可以在新对象中根据实际需要有选择性地调用成员对象的操作；合成复用可以在运行时动态进行，"),t("u",[v._v("新对象可以动态地引用与成员对象类型相同的其他对象")]),v._v("。")])]),v._v(" "),t("li",[t("p",[v._v("一个实例(加深理解合成复用原则)：")])])]),v._v(" "),t("p",[t("strong",[v._v("第七种：迪米特法则(最少知识原则)")])]),v._v(" "),t("ul",[t("li",[t("p",[v._v("迪米特法则："),t("strong",[v._v("一个软件实体应当尽可能少地与其他实体发生相互作用。")])])]),v._v(" "),t("li",[t("p",[v._v("迪米特法则可降低系统的耦合度，使类与类之间保持松散的耦合关系。")])]),v._v(" "),t("li",[t("p",[v._v("迪米特法则要求我们在设计系统时，"),t("u",[v._v("应该尽量减少对象之间的交互")]),v._v("，如果两个对象之间不必彼此直接通信，那么这两个对象就不应当发生任何直接的相互作用，"),t("u",[v._v("如果其中的一个对象需要调用另一个对象的某一个方法的话，可以通过第三者转发这个调用")]),v._v("。简言之，就是"),t("u",[v._v("通过引入一个合理的第三者来降低现有对象之间的耦合度")]),v._v("。")])]),v._v(" "),t("li",[t("p",[v._v("在将迪米特法则运用到系统设计中时，要注意下面的几点："),t("u",[v._v("在类的划分上，应当尽量创建松耦合的类，类之间的耦合度越低，就越有利于复用")]),v._v("，一个处在松耦合中的类一旦被修改，不会对关联的类造成太大波及；"),t("u",[v._v("在类的结构设计上，每一个类都应当尽量降低其成员变量和成员函数的访问权限")]),v._v("；在类的设计上，只要有可能，一个类型应当设计成不变类；"),t("u",[v._v("在对其他类的引用上，一个对象对其他对象的引用应当降到最低")]),v._v("。")])]),v._v(" "),t("li",[t("p",[v._v("一个实例图：")]),v._v(" "),t("img",{staticStyle:{zoom:"67%"},attrs:{src:"C:\\Users\\hp\\AppData\\Roaming\\Typora\\typora-user-images\\image-20220224160620659.png"}}),v._v(" "),t("img",{staticStyle:{zoom:"67%"},attrs:{src:"C:\\Users\\hp\\AppData\\Roaming\\Typora\\typora-user-images\\image-20220224160640072.png"}})])])])}),[],!1,null,null,null);_.default=r.exports}}]);