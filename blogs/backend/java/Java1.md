---
title: Java基础知识整理
date: 2021-11-15
tags:
 - java
categories:
 - 后端
---

:::tip

这里是对于Java基础知识的整理，主要来自于《head java first》，还有一些博客上面内容的整理、

:::

<!-- more -->

- 一个程序只需要一个main来运行（Java程序是用一组类所组成，其中有一个类会带有启动用的main()方法）

  

- 覆盖override的意思是由子类重新定义继承下来的方法，以改变或者延申此方法的行为

  

- 对象

  - 对象本身已知的事物被称为实例变量（状态）

  - 对象可以执行的动作被称为方法（行为）

    

- 类和对象的区别

  - 类会告诉虚拟机如何创建某种类型的对象

  - 根据某类创建出来的对象都会由自己的实例变量

    

- 真正的java程序只会让对象与对象交互（相互调用方法）

  

- 对象变量？

  - 没有对象变量，只有对象引用变量

  - 对象引用变量保存的是存取对象的方法（它并不是对象的容器，而是类似于指向对象的指针）

    

- 数组

  - 数组本身是对象

  - 一旦数组被声明出来，你就只能装入所声明类型的元素

  - 对数组的操作可以不需要使用变量名称，只需要数组索引

    

- 方法参数

  - 如果方法有参数，你一定要以正确数量，类型和顺序来传入参数

    

- 实例变量于局部变量的差别

  - 实例变量声明在类内，有默认值；局部变量声明在方法中，，在使用前必须初始化，没有默认值

    

- ==运算符和equals()方法区别

  - ==判断两个引用是否指向同一对象

  - equals比较两个对象在意义上是否相等（即不需要指向同一对象）

    

- <u>继承下来的方法可以被覆盖掉，但是实例变量不能被覆盖掉</u>。

  

- Java程序只是由一堆类组成的，因此，子类不需要重新编译就能运用到新版本的父类

  

- 伪码，测试码和真实码

  - 伪码：节约时间，文档的效果，对于复杂程序有必要（注意伪码应该描述要做i什么事情而不是如何做）

  - 测试码：这是单独写好的一些类或者方法，通过调用一些写好的类和方法，输入一些数据，测试

    

- java中的循环

  1. 基础for循环：  
      <img :src="$withBase('/imgs/java的for循环语法格式.PNG')" alt="mixureSecure">

  2. 加强版for循环：
     这主要是用于数组的增强型for循环。  
     Java增强for循环语法格式如下：  
     <img :src="$withBase('/imgs/Java增强for循环语法格式.PNG')" alt="mixureSecure">  
     实例：  

     <img :src="$withBase('/imgs/Java增强for循环实例.PNG')" alt="mixureSecure">

     

- 当我们调用对象引用方法的时候，我们会调用到与该对象类型最接近的方法，也就是说：最低阶的会胜出（即先从层次树的最下方开始找，没找到再依次向上，直到找到为止）。

  

- 引用类型与对象的类型必须相符，但是在<mark>多态</mark>下,引用与对象可以是不同的类型。  
  例如：Animal myDog() = new Dog().    
  原因：这是因为运用多态时，<u>引用类型可以是实际对象类型的父类</u>。  
  拓展： 参数和返回类型也可以多态（<u>使用多态参数</u>：将参数声明成父类类型，我就可以在运行时传入任何的子类对象）。

  

- 防止某个类被作为子类的三种方法：

  1. 存取控制：可以不标记为公有，而<u>非公有的类只能被同一个包的类作为子类</u>。

  2. final修饰符：这表示它是继承树的末端，不能被继承。

  3. 让类只拥有private的构造程序。

     

- 方法覆盖的规则：

  1. 参数必须要一样

  2. 返回类型必须要兼容（子类必须要声明返回一样的类型或者该类型的子型）

  3. 不能降低方法的存取权限（一样或者更加开放）

     

- 方法重载：

  - 重载的意义：两个方法名称相同，但是参数必须不同

  - 重载与多态毫无关系

  - 重载可以有同一方法的多个不同参数版本以方便调用

  - 返回类型可以不同

  - 参数必须不同！！！

  - 可以更改存取权限

    

- 抽象类：

  - 抽象类代表<u>没有人能够创建出该类的实例</u>(无法实例化)

  - 抽象类除了<u>被继承</u>之外，是没有用途，没有值，没有目的。

  - 我们可以强迫子类实现抽象类的抽象方法

  - 抽象方法实际上相当于定义了“规范”

  - 合理设计抽象类和接口，可以充分地复用代码

    

- 抽象方法

  - 抽象的方法没有实体，例如：<java>public abstract void eat()</java>

  - 如果我们声明出一个抽象的方法，就必须将类也标记为抽象的

  - <u>抽象方法的意义</u>：就算无法实现出方法的内容，也可以<u>定义出一组子型共同的协议</u>。这样做的好处是：<u>多态</u>,多态的好处在于所有子型都会有那些抽象的方法。<mark>这里没有完全理解！！！</mark>mark>

  - 抽象的方法没有内容，它是为了标记出多态而存在。

  - 必须实现所有抽象的方法（Java很注重你的具体子类有没有实现这些方法）<mark>没有理解！！！</mark>

    

- 从ArrayList<Object>取出的Object都会被当作是Object这个类的实例，编译器无法将此对象识别为Object以外的事物

  - 可以赋值任何东西给Object类型的引用，但是不能将Object赋值给Dog类型的引用；
  - 当一个对象被声明为Object类型的对象所引用时，它无法再赋值给原来类型的变量；
  - 编译器是<mark>根据引用类型来判断有哪些method可以调用</mark>mark>，而不是根据Object确定的类型(<u>例如</u>：如果对象的类型是Snowboard，而引用它的却是Object，则它不能调用Snowboard的方法)。
  - <u>转换为原来的类型</u>：Dog d= (Dog) o,也可以事先判断它是不是Dog类型。

  

- 接口

  - <mark>接口可以解决多重继承问题</mark>mark>而不至于出现致命方块问题（Java不允许多重继承，因为那样会出现致命方块的问题）

  - 接口为什么可以解决多重继承问题？（<mark>没有懂</mark>）

  - 接口就好像是<mark>纯抽象类</mark>，所有的接口的方法都是抽象的，所以任何类都必须要实现这些方法。

  - 接口的定义：public<u> interface</u> Pet {...}

  - 接口的实现：public class Dog extends Canine <u>implements</u> Pet {...}  (实现的接口必须要在某个类的继承之下)。

  - 使用接口就可以继承超过一个以上的来源

  - 类可以实现多个接口

  - 当用接口作为多态类型时，对象可以来自任何地方（<u>只要该对象来自有实现此接口的类</u>）

    

- 实例变量与局部变量

  - 实例变量是被声明在类而不是方法里面，他们代表每个独立对象的”字段“（实例变量存在于所属的对象里）（实例变量存在于对象所属的堆空间上）

  - 局部变量和方法的参数都是被声明在方法里的，它们是暂时的，且生命周期只限于方法被放在栈上的这段期间（也就是方法调用至执行完毕为止）

    

- 构造函数

  - 构造函数并不是方法
  - 唯一能够调用构造函数的办法打就是<u>新建一个类</u>
  - 构造函数带有你在<u>初始化对象时会执行的程序代码</u>
  - 构造函数<mark>无返回类型</mark>mark>,它的名称与类的名称相同
  - 构造函数不会被继承
  - 如果我们在创建对象时，需要有程序代码帮忙初始化，就得自己编写构造函数(<mark>没有看懂</mark>mark>)
  - ①如果你没有写构造函数，编译器就会帮你写一个无参数的构造函数；②如果你已经写了一个有参数的构造函数，则编译器就不会再帮你写一个无参数的构造函数；③如果类有一个以上的构造函数，则参数必须不一样
  - <mark><u>重点</u></mark>:在创建新对象时，所有继承下来的构造函数都会执行（<u>原因</u>:每个类至少有一个构造函数，且<u>每个构造函数都会在子类对象创建时期执行</u>）。
  - 如何调用父类的构造函数：
    - <mark>重点</mark>:在我们的构造函数中调用super()会把父类的构造函数放在堆栈的最上方，父类的构造函数会调用它的父类构造函数，接着会一路上直到Object的构造函数为止(<u>一层一层地调用</u>);然后一路执行，弹回到原来的构造函数。
    - 如果我们没有调用super(),<u>编译器会帮助我们调用无参数的·super()方法</u>。
    - <mark>对于super()的调用必须是构造函数的第一个语句</mark>mark>
  - 从某个构造函数调用<u>重载版</u>的另一个构造函数：
    - 每个构造函数可以选择调用this()或者super().但是不能同时调用
    - this()可以调用同一类的另外一个构造函数，且必须是第一行语句

  

- 静态方法 vs 非静态方法

  - 静态方法
    - 在外部调用静态方法的方式：类别.方法名，对象名.方法名。（<mark>调用静态方法可以无需创建对象</mark>）。
    - 静态方法在访问本类的成员时，只允许访问静态成员（静态成员变量和静态方法），不允许访问实例成员变量和实例方法
    - main()方法是一个典型的静态方法，所以它可以由系统在创建对象之前就调用
    - static可以标志出不需要实例的方法
  - 静态变量：
    - 它的值对于所有的实例来说都相同（静态变量的作用是被同类的所有实例共享的变量）   
    - 静态变量是在类被加载时初始化的（静态变量会在该类的任何静态方法之前就被初始化）  
    - 若我们没有给静态变量赋初值，那么他就会被设定默认值（该变量类型的默认值）  
  - 非静态方法（实例方法）
    - 在外部调用静态方法的方式：对象名.方法名。
    
    - 实例方法在访问本类的成员时，无限制
    
      

- ++++++++++++++++++++++++<mark>未完待续</mark>+++++++++++++++++++++++++++++++++
